{"version":3,"file":"groupNode-BPp-JmEq.js","sources":["../../src/utils/executableGroupNodeChildDTO.ts","../../src/extensions/core/groupNodeManage.ts","../../src/utils/mathUtil.ts","../../src/utils/nodeDefUtil.ts","../../src/extensions/core/widgetInputs.ts","../../src/extensions/core/groupNode.ts"],"sourcesContent":["import {\n  type ExecutableLGraphNode,\n  ExecutableNodeDTO,\n  type ExecutionId,\n  type LGraphNode,\n  type NodeId,\n  type SubgraphNode\n} from '@comfyorg/litegraph'\n\nimport type { GroupNodeHandler } from '@/extensions/core/groupNode'\n\nexport class ExecutableGroupNodeChildDTO extends ExecutableNodeDTO {\n  groupNodeHandler?: GroupNodeHandler\n\n  constructor(\n    /** The actual node that this DTO wraps. */\n    node: LGraphNode | SubgraphNode,\n    /** A list of subgraph instance node IDs from the root graph to the containing instance. @see {@link id} */\n    subgraphNodePath: readonly NodeId[],\n    /** A flattened map of all DTOs in this node network. Subgraph instances have been expanded into their inner nodes. */\n    nodesByExecutionId: Map<ExecutionId, ExecutableLGraphNode>,\n    /** The actual subgraph instance that contains this node, otherise undefined. */\n    subgraphNode?: SubgraphNode | undefined,\n    groupNodeHandler?: GroupNodeHandler\n  ) {\n    super(node, subgraphNodePath, nodesByExecutionId, subgraphNode)\n    this.groupNodeHandler = groupNodeHandler\n  }\n\n  override resolveInput(slot: number) {\n    const inputNode = this.node.getInputNode(slot)\n    if (!inputNode) return\n\n    const link = this.node.getInputLink(slot)\n    if (!link) throw new Error('Failed to get input link')\n\n    const id = String(inputNode.id).split(':').at(-1)\n    if (id === undefined) throw new Error('Invalid input node id')\n\n    const inputNodeDto = this.nodesByExecutionId?.get(id)\n    if (!inputNodeDto) {\n      throw new Error(\n        `Failed to get input node ${id} for group node child ${this.id} with slot ${slot}`\n      )\n    }\n\n    return {\n      node: inputNodeDto,\n      origin_id: String(inputNode.id),\n      origin_slot: link.origin_slot\n    }\n  }\n}\n","import {\n  type LGraphNode,\n  type LGraphNodeConstructor,\n  LiteGraph\n} from '@comfyorg/litegraph'\n\nimport { useToastStore } from '@/stores/toastStore'\n\nimport { type ComfyApp, app } from '../../scripts/app'\nimport { $el } from '../../scripts/ui'\nimport { ComfyDialog } from '../../scripts/ui/dialog'\nimport { DraggableList } from '../../scripts/ui/draggableList'\nimport { GroupNodeConfig, GroupNodeHandler } from './groupNode'\nimport './groupNodeManage.css'\n\nconst ORDER: symbol = Symbol()\nconst PREFIX = 'workflow'\nconst SEPARATOR = '>'\n\n// @ts-expect-error fixme ts strict error\nfunction merge(target, source) {\n  if (typeof target === 'object' && typeof source === 'object') {\n    for (const key in source) {\n      const sv = source[key]\n      if (typeof sv === 'object') {\n        let tv = target[key]\n        if (!tv) tv = target[key] = {}\n        merge(tv, source[key])\n      } else {\n        target[key] = sv\n      }\n    }\n  }\n\n  return target\n}\n\nexport class ManageGroupDialog extends ComfyDialog<HTMLDialogElement> {\n  // @ts-expect-error fixme ts strict error\n  tabs: Record<\n    'Inputs' | 'Outputs' | 'Widgets',\n    { tab: HTMLAnchorElement; page: HTMLElement }\n  >\n  selectedNodeIndex: number | null | undefined\n  selectedTab: keyof ManageGroupDialog['tabs'] = 'Inputs'\n  selectedGroup: string | undefined\n  modifications: Record<\n    string,\n    Record<\n      string,\n      Record<\n        string,\n        { name?: string | undefined; visible?: boolean | undefined }\n      >\n    >\n  > = {}\n  // @ts-expect-error fixme ts strict error\n  nodeItems: any[]\n  app: ComfyApp\n  // @ts-expect-error fixme ts strict error\n  groupNodeType: LGraphNodeConstructor<LGraphNode>\n  groupNodeDef: any\n  groupData: any\n\n  // @ts-expect-error fixme ts strict error\n  innerNodesList: HTMLUListElement\n  // @ts-expect-error fixme ts strict error\n  widgetsPage: HTMLElement\n  // @ts-expect-error fixme ts strict error\n  inputsPage: HTMLElement\n  // @ts-expect-error fixme ts strict error\n  outputsPage: HTMLElement\n  draggable: any\n\n  get selectedNodeInnerIndex() {\n    // @ts-expect-error fixme ts strict error\n    return +this.nodeItems[this.selectedNodeIndex].dataset.nodeindex\n  }\n\n  // @ts-expect-error fixme ts strict error\n  constructor(app) {\n    super()\n    this.app = app\n    this.element = $el('dialog.comfy-group-manage', {\n      parent: document.body\n    }) as HTMLDialogElement\n  }\n\n  // @ts-expect-error fixme ts strict error\n  changeTab(tab) {\n    this.tabs[this.selectedTab].tab.classList.remove('active')\n    this.tabs[this.selectedTab].page.classList.remove('active')\n    // @ts-expect-error fixme ts strict error\n    this.tabs[tab].tab.classList.add('active')\n    // @ts-expect-error fixme ts strict error\n    this.tabs[tab].page.classList.add('active')\n    this.selectedTab = tab\n  }\n\n  // @ts-expect-error fixme ts strict error\n  changeNode(index, force?) {\n    if (!force && this.selectedNodeIndex === index) return\n\n    if (this.selectedNodeIndex != null) {\n      this.nodeItems[this.selectedNodeIndex].classList.remove('selected')\n    }\n    this.nodeItems[index].classList.add('selected')\n    this.selectedNodeIndex = index\n\n    if (!this.buildInputsPage() && this.selectedTab === 'Inputs') {\n      this.changeTab('Widgets')\n    }\n    if (!this.buildWidgetsPage() && this.selectedTab === 'Widgets') {\n      this.changeTab('Outputs')\n    }\n    if (!this.buildOutputsPage() && this.selectedTab === 'Outputs') {\n      this.changeTab('Inputs')\n    }\n\n    this.changeTab(this.selectedTab)\n  }\n\n  getGroupData() {\n    this.groupNodeType = LiteGraph.registered_node_types[\n      `${PREFIX}${SEPARATOR}` + this.selectedGroup\n    ] as LGraphNodeConstructor<LGraphNode>\n    this.groupNodeDef = this.groupNodeType.nodeData\n    this.groupData = GroupNodeHandler.getGroupData(this.groupNodeType)\n  }\n\n  // @ts-expect-error fixme ts strict error\n  changeGroup(group, reset = true) {\n    this.selectedGroup = group\n    this.getGroupData()\n\n    const nodes = this.groupData.nodeData.nodes\n    // @ts-expect-error fixme ts strict error\n    this.nodeItems = nodes.map((n, i) =>\n      $el(\n        'li.draggable-item',\n        {\n          dataset: {\n            nodeindex: n.index + ''\n          },\n          onclick: () => {\n            this.changeNode(i)\n          }\n        },\n        [\n          $el('span.drag-handle'),\n          $el(\n            'div',\n            {\n              textContent: n.title ?? n.type\n            },\n            n.title\n              ? $el('span', {\n                  textContent: n.type\n                })\n              : []\n          )\n        ]\n      )\n    )\n\n    this.innerNodesList.replaceChildren(...this.nodeItems)\n\n    if (reset) {\n      this.selectedNodeIndex = null\n      this.changeNode(0)\n    } else {\n      const items = this.draggable.getAllItems()\n      // @ts-expect-error fixme ts strict error\n      let index = items.findIndex((item) => item.classList.contains('selected'))\n      if (index === -1) index = this.selectedNodeIndex\n      this.changeNode(index, true)\n    }\n\n    const ordered = [...nodes]\n    this.draggable?.dispose()\n    this.draggable = new DraggableList(this.innerNodesList, 'li')\n    this.draggable.addEventListener(\n      'dragend',\n      // @ts-expect-error fixme ts strict error\n      ({ detail: { oldPosition, newPosition } }) => {\n        if (oldPosition === newPosition) return\n        ordered.splice(newPosition, 0, ordered.splice(oldPosition, 1)[0])\n        for (let i = 0; i < ordered.length; i++) {\n          this.storeModification({\n            nodeIndex: ordered[i].index,\n            section: ORDER,\n            prop: 'order',\n            value: i\n          })\n        }\n      }\n    )\n  }\n\n  storeModification(props: {\n    nodeIndex?: number\n    section: symbol\n    prop: string\n    value: any\n  }) {\n    const { nodeIndex, section, prop, value } = props\n    // @ts-expect-error fixme ts strict error\n    const groupMod = (this.modifications[this.selectedGroup] ??= {})\n    const nodesMod = (groupMod.nodes ??= {})\n    const nodeMod = (nodesMod[nodeIndex ?? this.selectedNodeInnerIndex] ??= {})\n    const typeMod = (nodeMod[section] ??= {})\n    if (typeof value === 'object') {\n      const objMod = (typeMod[prop] ??= {})\n      Object.assign(objMod, value)\n    } else {\n      typeMod[prop] = value\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  getEditElement(section, prop, value, placeholder, checked, checkable = true) {\n    if (value === placeholder) value = ''\n\n    const mods =\n      // @ts-expect-error fixme ts strict error\n      this.modifications[this.selectedGroup]?.nodes?.[\n        this.selectedNodeInnerIndex\n      ]?.[section]?.[prop]\n    if (mods) {\n      if (mods.name != null) {\n        value = mods.name\n      }\n      if (mods.visible != null) {\n        checked = mods.visible\n      }\n    }\n\n    return $el('div', [\n      $el('input', {\n        value,\n        placeholder,\n        type: 'text',\n        // @ts-expect-error fixme ts strict error\n        onchange: (e) => {\n          this.storeModification({\n            section,\n            prop,\n            value: { name: e.target.value }\n          })\n        }\n      }),\n      $el('label', { textContent: 'Visible' }, [\n        $el('input', {\n          type: 'checkbox',\n          checked,\n          disabled: !checkable,\n          // @ts-expect-error fixme ts strict error\n          onchange: (e) => {\n            this.storeModification({\n              section,\n              prop,\n              value: { visible: !!e.target.checked }\n            })\n          }\n        })\n      ])\n    ])\n  }\n\n  buildWidgetsPage() {\n    const widgets =\n      this.groupData.oldToNewWidgetMap[this.selectedNodeInnerIndex]\n    const items = Object.keys(widgets ?? {})\n    // @ts-expect-error fixme ts strict error\n    const type = app.graph.extra.groupNodes[this.selectedGroup]\n    const config = type.config?.[this.selectedNodeInnerIndex]?.input\n    this.widgetsPage.replaceChildren(\n      ...items.map((oldName) => {\n        return this.getEditElement(\n          'input',\n          oldName,\n          widgets[oldName],\n          oldName,\n          config?.[oldName]?.visible !== false\n        )\n      })\n    )\n    return !!items.length\n  }\n\n  buildInputsPage() {\n    const inputs = this.groupData.nodeInputs[this.selectedNodeInnerIndex]\n    const items = Object.keys(inputs ?? {})\n    // @ts-expect-error fixme ts strict error\n    const type = app.graph.extra.groupNodes[this.selectedGroup]\n    const config = type.config?.[this.selectedNodeInnerIndex]?.input\n    this.inputsPage.replaceChildren(\n      // @ts-expect-error fixme ts strict error\n      ...items\n        .map((oldName) => {\n          let value = inputs[oldName]\n          if (!value) {\n            return\n          }\n\n          return this.getEditElement(\n            'input',\n            oldName,\n            value,\n            oldName,\n            config?.[oldName]?.visible !== false\n          )\n        })\n        .filter(Boolean)\n    )\n    return !!items.length\n  }\n\n  buildOutputsPage() {\n    const nodes = this.groupData.nodeData.nodes\n    const innerNodeDef = this.groupData.getNodeDef(\n      nodes[this.selectedNodeInnerIndex]\n    )\n    const outputs = innerNodeDef?.output ?? []\n    const groupOutputs =\n      this.groupData.oldToNewOutputMap[this.selectedNodeInnerIndex]\n\n    // @ts-expect-error fixme ts strict error\n    const type = app.graph.extra.groupNodes[this.selectedGroup]\n    const config = type.config?.[this.selectedNodeInnerIndex]?.output\n    const node = this.groupData.nodeData.nodes[this.selectedNodeInnerIndex]\n    const checkable = node.type !== 'PrimitiveNode'\n    this.outputsPage.replaceChildren(\n      ...outputs\n        // @ts-expect-error fixme ts strict error\n        .map((type, slot) => {\n          const groupOutputIndex = groupOutputs?.[slot]\n          const oldName = innerNodeDef.output_name?.[slot] ?? type\n          let value = config?.[slot]?.name\n          const visible = config?.[slot]?.visible || groupOutputIndex != null\n          if (!value || value === oldName) {\n            value = ''\n          }\n          return this.getEditElement(\n            'output',\n            slot,\n            value,\n            oldName,\n            visible,\n            checkable\n          )\n        })\n        .filter(Boolean)\n    )\n    return !!outputs.length\n  }\n\n  // @ts-expect-error fixme ts strict error\n  show(type?) {\n    const groupNodes = Object.keys(app.graph.extra?.groupNodes ?? {}).sort(\n      (a, b) => a.localeCompare(b)\n    )\n\n    this.innerNodesList = $el(\n      'ul.comfy-group-manage-list-items'\n    ) as HTMLUListElement\n    this.widgetsPage = $el('section.comfy-group-manage-node-page')\n    this.inputsPage = $el('section.comfy-group-manage-node-page')\n    this.outputsPage = $el('section.comfy-group-manage-node-page')\n    const pages = $el('div', [\n      this.widgetsPage,\n      this.inputsPage,\n      this.outputsPage\n    ])\n\n    this.tabs = [\n      ['Inputs', this.inputsPage],\n      ['Widgets', this.widgetsPage],\n      ['Outputs', this.outputsPage]\n      // @ts-expect-error fixme ts strict error\n    ].reduce((p, [name, page]: [string, HTMLElement]) => {\n      // @ts-expect-error fixme ts strict error\n      p[name] = {\n        tab: $el('a', {\n          onclick: () => {\n            this.changeTab(name)\n          },\n          textContent: name\n        }),\n        page\n      }\n      return p\n    }, {}) as any\n\n    const outer = $el('div.comfy-group-manage-outer', [\n      $el('header', [\n        $el('h2', 'Group Nodes'),\n        $el(\n          'select',\n          {\n            // @ts-expect-error fixme ts strict error\n            onchange: (e) => {\n              this.changeGroup(e.target.value)\n            }\n          },\n          groupNodes.map((g) =>\n            $el('option', {\n              textContent: g,\n              selected: `${PREFIX}${SEPARATOR}${g}` === type,\n              value: g\n            })\n          )\n        )\n      ]),\n      $el('main', [\n        $el('section.comfy-group-manage-list', this.innerNodesList),\n        $el('section.comfy-group-manage-node', [\n          $el(\n            'header',\n            Object.values(this.tabs).map((t) => t.tab)\n          ),\n          pages\n        ])\n      ]),\n      $el('footer', [\n        $el(\n          'button.comfy-btn',\n          {\n            onclick: () => {\n              const node = app.graph.nodes.find(\n                (n) => n.type === `${PREFIX}${SEPARATOR}` + this.selectedGroup\n              )\n              if (node) {\n                useToastStore().addAlert(\n                  'This group node is in use in the current workflow, please first remove these.'\n                )\n                return\n              }\n              if (\n                confirm(\n                  `Are you sure you want to remove the node: \"${this.selectedGroup}\"`\n                )\n              ) {\n                // @ts-expect-error fixme ts strict error\n                delete app.graph.extra.groupNodes[this.selectedGroup]\n                LiteGraph.unregisterNodeType(\n                  `${PREFIX}${SEPARATOR}` + this.selectedGroup\n                )\n              }\n              this.show()\n            }\n          },\n          'Delete Group Node'\n        ),\n        $el(\n          'button.comfy-btn',\n          {\n            onclick: async () => {\n              let nodesByType\n              let recreateNodes = []\n              const types = {}\n              for (const g in this.modifications) {\n                // @ts-expect-error fixme ts strict error\n                const type = app.graph.extra.groupNodes[g]\n                let config = (type.config ??= {})\n\n                let nodeMods = this.modifications[g]?.nodes\n                if (nodeMods) {\n                  const keys = Object.keys(nodeMods)\n                  // @ts-expect-error fixme ts strict error\n                  if (nodeMods[keys[0]][ORDER]) {\n                    // If any node is reordered, they will all need sequencing\n                    const orderedNodes = []\n                    const orderedMods = {}\n                    const orderedConfig = {}\n\n                    for (const n of keys) {\n                      // @ts-expect-error fixme ts strict error\n                      const order = nodeMods[n][ORDER].order\n                      orderedNodes[order] = type.nodes[+n]\n                      // @ts-expect-error fixme ts strict error\n                      orderedMods[order] = nodeMods[n]\n                      orderedNodes[order].index = order\n                    }\n\n                    // Rewrite links\n                    for (const l of type.links) {\n                      if (l[0] != null) l[0] = type.nodes[l[0]].index\n                      if (l[2] != null) l[2] = type.nodes[l[2]].index\n                    }\n\n                    // Rewrite externals\n                    if (type.external) {\n                      for (const ext of type.external) {\n                        ext[0] = type.nodes[ext[0]]\n                      }\n                    }\n\n                    // Rewrite modifications\n                    for (const id of keys) {\n                      if (config[id]) {\n                        // @ts-expect-error fixme ts strict error\n                        orderedConfig[type.nodes[id].index] = config[id]\n                      }\n                      delete config[id]\n                    }\n\n                    type.nodes = orderedNodes\n                    nodeMods = orderedMods\n                    type.config = config = orderedConfig\n                  }\n\n                  merge(config, nodeMods)\n                }\n\n                // @ts-expect-error fixme ts strict error\n                types[g] = type\n\n                if (!nodesByType) {\n                  nodesByType = app.graph.nodes.reduce((p, n) => {\n                    // @ts-expect-error fixme ts strict error\n                    p[n.type] ??= []\n                    // @ts-expect-error fixme ts strict error\n                    p[n.type].push(n)\n                    return p\n                  }, {})\n                }\n\n                // @ts-expect-error fixme ts strict error\n                const nodes = nodesByType[`${PREFIX}${SEPARATOR}` + g]\n                if (nodes) recreateNodes.push(...nodes)\n              }\n\n              await GroupNodeConfig.registerFromWorkflow(types, {})\n\n              for (const node of recreateNodes) {\n                node.recreate()\n              }\n\n              this.modifications = {}\n              this.app.graph.setDirtyCanvas(true, true)\n              this.changeGroup(this.selectedGroup, false)\n            }\n          },\n          'Save'\n        ),\n        $el(\n          'button.comfy-btn',\n          { onclick: () => this.element.close() },\n          'Close'\n        )\n      ])\n    ])\n\n    this.element.replaceChildren(outer)\n    this.changeGroup(\n      type\n        ? groupNodes.find((g) => `${PREFIX}${SEPARATOR}${g}` === type) ??\n            groupNodes[0]\n        : groupNodes[0]\n    )\n    this.element.showModal()\n\n    this.element.addEventListener('close', () => {\n      this.draggable?.dispose()\n      this.element.remove()\n    })\n  }\n}\n","/**\n * Finds the greatest common divisor (GCD) for two numbers.\n *\n * @param a - The first number.\n * @param b - The second number.\n * @returns The GCD of the two numbers.\n */\nexport const gcd = (a: number, b: number): number => {\n  return b === 0 ? a : gcd(b, a % b)\n}\n\n/**\n * Finds the least common multiple (LCM) for two numbers.\n *\n * @param a - The first number.\n * @param b - The second number.\n * @returns The LCM of the two numbers.\n */\nexport const lcm = (a: number, b: number): number => {\n  return Math.abs(a * b) / gcd(a, b)\n}\n","import _ from 'lodash'\n\nimport type {\n  ComboInputSpec,\n  ComboInputSpecV2,\n  FloatInputSpec,\n  InputSpec,\n  IntInputSpec,\n  NumericInputOptions\n} from '@/schemas/nodeDefSchema'\nimport {\n  getComboSpecComboOptions,\n  getInputSpecType,\n  isComboInputSpec,\n  isFloatInputSpec,\n  isIntInputSpec\n} from '@/schemas/nodeDefSchema'\n\nimport { lcm } from './mathUtil'\n\nconst IGNORE_KEYS = new Set<string>([\n  'default',\n  'forceInput',\n  'defaultInput',\n  'control_after_generate',\n  'multiline',\n  'tooltip',\n  'dynamicPrompts'\n])\n\nconst getRange = (options: NumericInputOptions) => {\n  const min = options.min ?? -Infinity\n  const max = options.max ?? Infinity\n  return { min, max }\n}\n\nconst mergeNumericInputSpec = <T extends IntInputSpec | FloatInputSpec>(\n  spec1: T,\n  spec2: T\n): T | null => {\n  const type = spec1[0]\n  const options1 = spec1[1] ?? {}\n  const options2 = spec2[1] ?? {}\n\n  const range1 = getRange(options1)\n  const range2 = getRange(options2)\n\n  // If the ranges do not overlap, return null\n  if (range1.min > range2.max || range1.max < range2.min) {\n    return null\n  }\n\n  const step1 = options1.step ?? 1\n  const step2 = options2.step ?? 1\n\n  const mergedOptions = {\n    // Take intersection of ranges\n    min: Math.max(range1.min, range2.min),\n    max: Math.min(range1.max, range2.max),\n    step: lcm(step1, step2)\n  }\n\n  return mergeCommonInputSpec(\n    [type, { ...options1, ...mergedOptions }] as T,\n    [type, { ...options2, ...mergedOptions }] as T\n  )\n}\n\nconst mergeComboInputSpec = <T extends ComboInputSpec | ComboInputSpecV2>(\n  spec1: T,\n  spec2: T\n): T | null => {\n  const options1 = spec1[1] ?? {}\n  const options2 = spec2[1] ?? {}\n\n  const comboOptions1 = getComboSpecComboOptions(spec1)\n  const comboOptions2 = getComboSpecComboOptions(spec2)\n\n  const intersection = _.intersection(comboOptions1, comboOptions2)\n\n  // If the intersection is empty, return null\n  if (intersection.length === 0) {\n    return null\n  }\n\n  return mergeCommonInputSpec(\n    ['COMBO', { ...options1, options: intersection }] as T,\n    ['COMBO', { ...options2, options: intersection }] as T\n  )\n}\n\nconst mergeCommonInputSpec = <T extends InputSpec>(\n  spec1: T,\n  spec2: T\n): T | null => {\n  const type = getInputSpecType(spec1)\n  const options1 = spec1[1] ?? {}\n  const options2 = spec2[1] ?? {}\n\n  const compareKeys = _.union(_.keys(options1), _.keys(options2)).filter(\n    (key) => !IGNORE_KEYS.has(key)\n  )\n\n  const mergeIsValid = compareKeys.every((key) => {\n    const value1 = options1[key]\n    const value2 = options2[key]\n    return value1 === value2 || (_.isNil(value1) && _.isNil(value2))\n  })\n\n  return mergeIsValid ? ([type, { ...options1, ...options2 }] as T) : null\n}\n\n/**\n * Merges two input specs.\n *\n * @param spec1 - The first input spec.\n * @param spec2 - The second input spec.\n * @returns The merged input spec, or null if the specs are not mergeable.\n */\nexport const mergeInputSpec = (\n  spec1: InputSpec,\n  spec2: InputSpec\n): InputSpec | null => {\n  const type1 = getInputSpecType(spec1)\n  const type2 = getInputSpecType(spec2)\n\n  if (type1 !== type2) {\n    return null\n  }\n\n  if (isIntInputSpec(spec1) || isFloatInputSpec(spec1)) {\n    return mergeNumericInputSpec(spec1, spec2 as typeof spec1)\n  }\n\n  if (isComboInputSpec(spec1)) {\n    return mergeComboInputSpec(spec1, spec2 as typeof spec1)\n  }\n\n  return mergeCommonInputSpec(spec1, spec2)\n}\n","import { LGraphNode, LiteGraph } from '@comfyorg/litegraph'\nimport type {\n  INodeInputSlot,\n  INodeOutputSlot,\n  ISlotType,\n  LLink,\n  Vector2\n} from '@comfyorg/litegraph'\nimport type { CanvasPointerEvent } from '@comfyorg/litegraph/dist/types/events'\nimport type { IBaseWidget } from '@comfyorg/litegraph/dist/types/widgets'\n\nimport {\n  type CallbackParams,\n  useChainCallback\n} from '@/composables/functional/useChainCallback'\nimport type { InputSpec } from '@/schemas/nodeDefSchema'\nimport { app } from '@/scripts/app'\nimport { ComfyWidgets, addValueControlWidgets } from '@/scripts/widgets'\nimport { CONFIG, GET_CONFIG } from '@/services/litegraphService'\nimport { mergeInputSpec } from '@/utils/nodeDefUtil'\nimport { applyTextReplacements } from '@/utils/searchAndReplace'\nimport { isPrimitiveNode } from '@/utils/typeGuardUtil'\n\nconst replacePropertyName = 'Run widget replace on values'\nexport class PrimitiveNode extends LGraphNode {\n  controlValues?: any[]\n  lastType?: string\n  static override category: string\n  constructor(title: string) {\n    super(title)\n    this.addOutput('connect to widget input', '*')\n    this.serialize_widgets = true\n    this.isVirtualNode = true\n\n    if (!this.properties || !(replacePropertyName in this.properties)) {\n      this.addProperty(replacePropertyName, false, 'boolean')\n    }\n  }\n\n  override applyToGraph(extraLinks: LLink[] = []) {\n    if (!this.outputs[0].links?.length) return\n\n    const links = [\n      ...this.outputs[0].links.map((l) => app.graph.links[l]),\n      ...extraLinks\n    ]\n    let v = this.widgets?.[0].value\n    if (v && this.properties[replacePropertyName]) {\n      v = applyTextReplacements(app.graph.nodes, v as string)\n    }\n\n    // For each output link copy our value over the original widget value\n    for (const linkInfo of links) {\n      const node = this.graph?.getNodeById(linkInfo.target_id)\n      const input = node?.inputs[linkInfo.target_slot]\n      if (!input) {\n        console.warn('Unable to resolve node or input for link', linkInfo)\n        continue\n      }\n\n      const widgetName = input.widget?.name\n      if (!widgetName) {\n        console.warn('Invalid widget or widget name', input.widget)\n        continue\n      }\n\n      const widget = node.widgets?.find((w) => w.name === widgetName)\n      if (!widget) {\n        console.warn(\n          `Unable to find widget \"${widgetName}\" on node [${node.id}]`\n        )\n        continue\n      }\n\n      widget.value = v\n      widget.callback?.(\n        widget.value,\n        app.canvas,\n        node,\n        app.canvas.graph_mouse,\n        {} as CanvasPointerEvent\n      )\n    }\n  }\n\n  override refreshComboInNode() {\n    const widget = this.widgets?.[0]\n    if (widget?.type === 'combo') {\n      // @ts-expect-error fixme ts strict error\n      widget.options.values = this.outputs[0].widget[GET_CONFIG]()[0]\n\n      // @ts-expect-error fixme ts strict error\n      if (!widget.options.values.includes(widget.value as string)) {\n        // @ts-expect-error fixme ts strict error\n        widget.value = widget.options.values[0]\n        ;(widget.callback as Function)(widget.value)\n      }\n    }\n  }\n\n  override onAfterGraphConfigured() {\n    if (this.outputs[0].links?.length && !this.widgets?.length) {\n      this.#onFirstConnection()\n\n      // Populate widget values from config data\n      if (this.widgets && this.widgets_values) {\n        for (let i = 0; i < this.widgets_values.length; i++) {\n          const w = this.widgets[i]\n          if (w) {\n            w.value = this.widgets_values[i] as any\n          }\n        }\n      }\n\n      // Merge values if required\n      this.#mergeWidgetConfig()\n    }\n  }\n\n  override onConnectionsChange(\n    _type: ISlotType,\n    _index: number,\n    connected: boolean\n  ) {\n    if (app.configuringGraph) {\n      // Dont run while the graph is still setting up\n      return\n    }\n\n    const links = this.outputs[0].links\n    if (connected) {\n      if (links?.length && !this.widgets?.length) {\n        this.#onFirstConnection()\n      }\n    } else {\n      // We may have removed a link that caused the constraints to change\n      this.#mergeWidgetConfig()\n\n      if (!links?.length) {\n        this.onLastDisconnect()\n      }\n    }\n  }\n\n  override onConnectOutput(\n    slot: number,\n    _type: string,\n    input: INodeInputSlot,\n    target_node: LGraphNode,\n    target_slot: number\n  ) {\n    // Fires before the link is made allowing us to reject it if it isn't valid\n    // No widget, we cant connect\n    if (!input.widget && !(input.type in ComfyWidgets)) {\n      return false\n    }\n\n    if (this.outputs[slot].links?.length) {\n      const valid = this.#isValidConnection(input)\n      if (valid) {\n        // On connect of additional outputs, copy our value to their widget\n        this.applyToGraph([{ target_id: target_node.id, target_slot } as LLink])\n      }\n      return valid\n    }\n\n    return true\n  }\n\n  #onFirstConnection(recreating?: boolean) {\n    // First connection can fire before the graph is ready on initial load so random things can be missing\n    if (!this.outputs[0].links) {\n      this.onLastDisconnect()\n      return\n    }\n    const linkId = this.outputs[0].links[0]\n    // @ts-expect-error fixme ts strict error\n    const link = this.graph.links[linkId]\n    if (!link) return\n\n    // @ts-expect-error fixme ts strict error\n    const theirNode = this.graph.getNodeById(link.target_id)\n    if (!theirNode || !theirNode.inputs) return\n\n    const input = theirNode.inputs[link.target_slot]\n    if (!input) return\n\n    let widget\n    if (!input.widget) {\n      if (!(input.type in ComfyWidgets)) return\n      widget = { name: input.name, [GET_CONFIG]: () => [input.type, {}] } //fake widget\n    } else {\n      widget = input.widget\n    }\n\n    // @ts-expect-error fixme ts strict error\n    const config = widget[GET_CONFIG]?.()\n    if (!config) return\n\n    const { type } = getWidgetType(config)\n    // Update our output to restrict to the widget type\n    this.outputs[0].type = type\n    this.outputs[0].name = type\n    this.outputs[0].widget = widget\n\n    this.#createWidget(\n      widget[CONFIG] ?? config,\n      theirNode,\n      widget.name,\n      // @ts-expect-error fixme ts strict error\n      recreating\n    )\n  }\n\n  #createWidget(\n    inputData: InputSpec,\n    node: LGraphNode,\n    widgetName: string,\n    recreating: boolean\n  ) {\n    let type = inputData[0]\n\n    if (type instanceof Array) {\n      type = 'COMBO'\n    }\n\n    // Store current size as addWidget resizes the node\n    const [oldWidth, oldHeight] = this.size\n    let widget: IBaseWidget | undefined\n    if (type in ComfyWidgets) {\n      widget = (ComfyWidgets[type](this, 'value', inputData, app) || {}).widget\n    } else {\n      // @ts-expect-error InputSpec is not typed correctly\n      widget = this.addWidget(type, 'value', null, () => {}, {})\n    }\n\n    if (node?.widgets && widget) {\n      const theirWidget = node.widgets.find((w) => w.name === widgetName)\n      if (theirWidget) {\n        widget.value = theirWidget.value\n      }\n    }\n\n    if (\n      !inputData?.[1]?.control_after_generate &&\n      (widget.type === 'number' || widget.type === 'combo')\n    ) {\n      let control_value = this.widgets_values?.[1]\n      if (!control_value) {\n        control_value = 'fixed'\n      }\n      addValueControlWidgets(\n        this,\n        widget,\n        control_value as string,\n        undefined,\n        inputData\n      )\n      let filter = this.widgets_values?.[2]\n      if (filter && this.widgets && this.widgets.length === 3) {\n        this.widgets[2].value = filter\n      }\n    }\n\n    // Restore any saved control values\n    const controlValues = this.controlValues\n    if (\n      this.widgets &&\n      this.lastType === this.widgets[0]?.type &&\n      controlValues?.length === this.widgets.length - 1\n    ) {\n      for (let i = 0; i < controlValues.length; i++) {\n        this.widgets[i + 1].value = controlValues[i]\n      }\n    }\n\n    // When our value changes, update other widgets to reflect our changes\n    // e.g. so LoadImage shows correct image\n    widget.callback = useChainCallback(widget.callback, () => {\n      this.applyToGraph()\n    })\n\n    // Use the biggest dimensions in case the widgets caused the node to grow\n    this.setSize([\n      Math.max(this.size[0], oldWidth),\n      Math.max(this.size[1], oldHeight)\n    ])\n\n    if (!recreating) {\n      // Grow our node more if required\n      const sz = this.computeSize()\n      if (this.size[0] < sz[0]) {\n        this.size[0] = sz[0]\n      }\n      if (this.size[1] < sz[1]) {\n        this.size[1] = sz[1]\n      }\n\n      requestAnimationFrame(() => {\n        this.onResize?.(this.size)\n      })\n    }\n  }\n\n  recreateWidget() {\n    const values = this.widgets?.map((w) => w.value)\n    this.#removeWidgets()\n    this.#onFirstConnection(true)\n    if (values?.length && this.widgets) {\n      for (let i = 0; i < this.widgets.length; i++)\n        this.widgets[i].value = values[i]\n    }\n    return this.widgets?.[0]\n  }\n\n  #mergeWidgetConfig() {\n    // Merge widget configs if the node has multiple outputs\n    const output = this.outputs[0]\n    const links = output.links ?? []\n\n    const hasConfig = !!output.widget?.[CONFIG]\n    if (hasConfig) {\n      delete output.widget?.[CONFIG]\n    }\n\n    if (links?.length < 2 && hasConfig) {\n      // Copy the widget options from the source\n      if (links.length) {\n        this.recreateWidget()\n      }\n\n      return\n    }\n    const config1 = (output.widget?.[GET_CONFIG] as () => InputSpec)?.()\n    if (!config1) return\n    const isNumber = config1[0] === 'INT' || config1[0] === 'FLOAT'\n    if (!isNumber) return\n\n    for (const linkId of links) {\n      const link = app.graph.links[linkId]\n      if (!link) continue // Can be null when removing a node\n\n      const theirNode = app.graph.getNodeById(link.target_id)\n      if (!theirNode) continue\n      const theirInput = theirNode.inputs[link.target_slot]\n\n      // Call is valid connection so it can merge the configs when validating\n      this.#isValidConnection(theirInput, hasConfig)\n    }\n  }\n\n  #isValidConnection(input: INodeInputSlot, forceUpdate?: boolean) {\n    // Only allow connections where the configs match\n    const output = this.outputs?.[0]\n    const config2 = (input.widget?.[GET_CONFIG] as () => InputSpec)?.()\n    if (!config2) return false\n\n    return !!mergeIfValid.call(\n      this,\n      output,\n      config2,\n      forceUpdate,\n      this.recreateWidget\n    )\n  }\n\n  #removeWidgets() {\n    if (this.widgets) {\n      // Allow widgets to cleanup\n      for (const w of this.widgets) {\n        if (w.onRemove) {\n          w.onRemove()\n        }\n      }\n\n      // Temporarily store the current values in case the node is being recreated\n      // e.g. by group node conversion\n      this.controlValues = []\n      this.lastType = this.widgets[0]?.type\n      for (let i = 1; i < this.widgets.length; i++) {\n        this.controlValues.push(this.widgets[i].value)\n      }\n      setTimeout(() => {\n        delete this.lastType\n        delete this.controlValues\n      }, 15)\n      this.widgets.length = 0\n    }\n  }\n\n  onLastDisconnect() {\n    // We cant remove + re-add the output here as if you drag a link over the same link\n    // it removes, then re-adds, causing it to break\n    this.outputs[0].type = '*'\n    this.outputs[0].name = 'connect to widget input'\n    delete this.outputs[0].widget\n\n    this.#removeWidgets()\n  }\n}\n\nexport function getWidgetConfig(\n  slot: INodeInputSlot | INodeOutputSlot\n): InputSpec {\n  return (slot.widget?.[CONFIG] ??\n    (slot.widget?.[GET_CONFIG] as () => InputSpec)?.() ?? [\n      '*',\n      {}\n    ]) as InputSpec\n}\n\nfunction getConfig(this: LGraphNode, widgetName: string) {\n  const { nodeData } = this.constructor\n  return (\n    nodeData?.input?.required?.[widgetName] ??\n    nodeData?.input?.optional?.[widgetName]\n  )\n}\n\n/**\n * Convert a widget to an input slot.\n * @deprecated Widget to socket conversion is no longer necessary, as they co-exist now.\n * @param node The node to convert the widget to an input slot for.\n * @param widget The widget to convert to an input slot.\n * @returns The input slot that was converted from the widget or undefined if the widget is not found.\n */\nexport function convertToInput(\n  node: LGraphNode,\n  widget: IBaseWidget\n): INodeInputSlot | undefined {\n  console.warn(\n    'Please remove call to convertToInput. Widget to socket conversion is no longer necessary, as they co-exist now.'\n  )\n  return node.inputs.find((slot) => slot.widget?.name === widget.name)\n}\n\nfunction getWidgetType(config: InputSpec) {\n  // Special handling for COMBO so we restrict links based on the entries\n  let type = config[0]\n  if (type instanceof Array) {\n    type = 'COMBO'\n  }\n  return { type }\n}\n\nexport function setWidgetConfig(\n  slot: INodeInputSlot | INodeOutputSlot,\n  config: InputSpec\n) {\n  if (!slot.widget) return\n  if (config) {\n    slot.widget[GET_CONFIG] = () => config\n  } else {\n    delete slot.widget\n  }\n\n  if ('link' in slot) {\n    const link = app.graph.links[slot.link ?? -1]\n    if (link) {\n      const originNode = app.graph.getNodeById(link.origin_id)\n      if (originNode && isPrimitiveNode(originNode)) {\n        if (config) {\n          originNode.recreateWidget()\n        } else if (!app.configuringGraph) {\n          originNode.disconnectOutput(0)\n          originNode.onLastDisconnect()\n        }\n      }\n    }\n  }\n}\n\nexport function mergeIfValid(\n  output: INodeOutputSlot | INodeInputSlot,\n  config2: InputSpec,\n  forceUpdate?: boolean,\n  recreateWidget?: () => void,\n  config1?: InputSpec\n): { customConfig: InputSpec[1] } {\n  if (!config1) {\n    config1 = getWidgetConfig(output)\n  }\n\n  const customSpec = mergeInputSpec(config1, config2)\n\n  if (customSpec || forceUpdate) {\n    if (customSpec) {\n      // @ts-expect-error fixme ts strict error\n      output.widget[CONFIG] = customSpec\n    }\n\n    // @ts-expect-error fixme ts strict error\n    const widget = recreateWidget?.call(this)\n    // When deleting a node this can be null\n    if (widget) {\n      // @ts-expect-error fixme ts strict error\n      const min = widget.options.min\n      // @ts-expect-error fixme ts strict error\n      const max = widget.options.max\n      // @ts-expect-error fixme ts strict error\n      if (min != null && widget.value < min) widget.value = min\n      // @ts-expect-error fixme ts strict error\n      if (max != null && widget.value > max) widget.value = max\n      // @ts-expect-error fixme ts strict error\n      widget.callback(widget.value)\n    }\n  }\n\n  return { customConfig: customSpec?.[1] ?? {} }\n}\n\napp.registerExtension({\n  name: 'Comfy.WidgetInputs',\n  async beforeRegisterNodeDef(nodeType, _nodeData, app) {\n    // @ts-expect-error adding extra property\n    nodeType.prototype.convertWidgetToInput = function (this: LGraphNode) {\n      console.warn(\n        'Please remove call to convertWidgetToInput. Widget to socket conversion is no longer necessary, as they co-exist now.'\n      )\n      return false\n    }\n\n    nodeType.prototype.onGraphConfigured = useChainCallback(\n      nodeType.prototype.onGraphConfigured,\n      function (this: LGraphNode) {\n        if (!this.inputs) return\n        this.widgets ??= []\n\n        for (const input of this.inputs) {\n          if (input.widget) {\n            const name = input.widget.name\n            if (!input.widget[GET_CONFIG]) {\n              input.widget[GET_CONFIG] = () => getConfig.call(this, name)\n            }\n\n            const w = this.widgets?.find((w) => w.name === name)\n            if (!w) {\n              this.removeInput(this.inputs.findIndex((i) => i === input))\n            }\n          }\n        }\n      }\n    )\n\n    nodeType.prototype.onConfigure = useChainCallback(\n      nodeType.prototype.onConfigure,\n      function (this: LGraphNode) {\n        if (!app.configuringGraph && this.inputs) {\n          // On copy + paste of nodes, ensure that widget configs are set up\n          for (const input of this.inputs) {\n            if (input.widget && !input.widget[GET_CONFIG]) {\n              const name = input.widget.name\n              input.widget[GET_CONFIG] = () => getConfig.call(this, name)\n            }\n          }\n        }\n      }\n    )\n\n    function isNodeAtPos(pos: Vector2) {\n      for (const n of app.graph.nodes) {\n        if (n.pos[0] === pos[0] && n.pos[1] === pos[1]) {\n          return true\n        }\n      }\n      return false\n    }\n\n    // Double click a widget input to automatically attach a primitive\n    const origOnInputDblClick = nodeType.prototype.onInputDblClick\n    nodeType.prototype.onInputDblClick = function (\n      this: LGraphNode,\n      ...[slot, ...args]: CallbackParams<typeof origOnInputDblClick>\n    ) {\n      const r = origOnInputDblClick?.apply(this, [slot, ...args])\n\n      const input = this.inputs[slot]\n      if (!input.widget) {\n        // Not a widget input or already handled input\n        if (\n          !(input.type in ComfyWidgets) &&\n          !(\n            (\n              input.widget?.[GET_CONFIG] as (() => InputSpec) | undefined\n            )?.()?.[0] instanceof Array\n          )\n        ) {\n          return r //also Not a ComfyWidgets input or combo (do nothing)\n        }\n      }\n\n      // Create a primitive node\n      const node = LiteGraph.createNode('PrimitiveNode')\n      if (!node) return r\n\n      app.graph.add(node)\n\n      // Calculate a position that wont directly overlap another node\n      const pos: [number, number] = [\n        this.pos[0] - node.size[0] - 30,\n        this.pos[1]\n      ]\n      while (isNodeAtPos(pos)) {\n        pos[1] += LiteGraph.NODE_TITLE_HEIGHT\n      }\n\n      node.pos = pos\n      node.connect(0, this, slot)\n      node.title = input.name\n\n      return r\n    }\n  },\n  registerCustomNodes() {\n    LiteGraph.registerNodeType(\n      'PrimitiveNode',\n      Object.assign(PrimitiveNode, {\n        title: 'Primitive'\n      })\n    )\n    PrimitiveNode.category = 'utils'\n  }\n})\n","import {\n  type ExecutableLGraphNode,\n  type ExecutionId,\n  LGraphNode,\n  LiteGraph,\n  SubgraphNode\n} from '@comfyorg/litegraph'\nimport { type NodeId } from '@comfyorg/litegraph/dist/LGraphNode'\n\nimport { t } from '@/i18n'\nimport {\n  ComfyLink,\n  ComfyNode,\n  ComfyWorkflowJSON\n} from '@/schemas/comfyWorkflowSchema'\nimport type { ComfyNodeDef } from '@/schemas/nodeDefSchema'\nimport { useDialogService } from '@/services/dialogService'\nimport { useNodeDefStore } from '@/stores/nodeDefStore'\nimport { useToastStore } from '@/stores/toastStore'\nimport { useWidgetStore } from '@/stores/widgetStore'\nimport { ComfyExtension } from '@/types/comfy'\nimport { ExecutableGroupNodeChildDTO } from '@/utils/executableGroupNodeChildDTO'\nimport { GROUP } from '@/utils/executableGroupNodeDto'\nimport { deserialiseAndCreate, serialise } from '@/utils/vintageClipboard'\n\nimport { api } from '../../scripts/api'\nimport { app } from '../../scripts/app'\nimport { ManageGroupDialog } from './groupNodeManage'\nimport { mergeIfValid } from './widgetInputs'\n\ntype GroupNodeWorkflowData = {\n  external: ComfyLink[]\n  links: ComfyLink[]\n  nodes: ComfyNode[]\n}\n\n// v1 Prefix + Separator: workflow/\n// v2 Prefix + Separator: workflow> (ComfyUI_frontend v1.2.63)\nconst PREFIX = 'workflow'\nconst SEPARATOR = '>'\n\nconst Workflow = {\n  InUse: {\n    Free: 0,\n    Registered: 1,\n    InWorkflow: 2\n  },\n  // @ts-expect-error fixme ts strict error\n  isInUseGroupNode(name) {\n    const id = `${PREFIX}${SEPARATOR}${name}`\n    // Check if lready registered/in use in this workflow\n    // @ts-expect-error fixme ts strict error\n    if (app.graph.extra?.groupNodes?.[name]) {\n      if (app.graph.nodes.find((n) => n.type === id)) {\n        return Workflow.InUse.InWorkflow\n      } else {\n        return Workflow.InUse.Registered\n      }\n    }\n    return Workflow.InUse.Free\n  },\n  storeGroupNode(name: string, data: GroupNodeWorkflowData) {\n    let extra = app.graph.extra\n    if (!extra) app.graph.extra = extra = {}\n    let groupNodes = extra.groupNodes\n    if (!groupNodes) extra.groupNodes = groupNodes = {}\n    // @ts-expect-error fixme ts strict error\n    groupNodes[name] = data\n  }\n}\n\nclass GroupNodeBuilder {\n  nodes: LGraphNode[]\n  // @ts-expect-error fixme ts strict error\n  nodeData: GroupNodeWorkflowData\n\n  constructor(nodes: LGraphNode[]) {\n    this.nodes = nodes\n  }\n\n  async build() {\n    const name = await this.getName()\n    if (!name) return\n\n    // Sort the nodes so they are in execution order\n    // this allows for widgets to be in the correct order when reconstructing\n    this.sortNodes()\n\n    this.nodeData = this.getNodeData()\n    Workflow.storeGroupNode(name, this.nodeData)\n\n    return { name, nodeData: this.nodeData }\n  }\n\n  async getName() {\n    const name = await useDialogService().prompt({\n      title: t('groupNode.create'),\n      message: t('groupNode.enterName'),\n      defaultValue: ''\n    })\n    if (!name) return\n    const used = Workflow.isInUseGroupNode(name)\n    switch (used) {\n      case Workflow.InUse.InWorkflow:\n        useToastStore().addAlert(\n          'An in use group node with this name already exists embedded in this workflow, please remove any instances or use a new name.'\n        )\n        return\n      case Workflow.InUse.Registered:\n        if (\n          !confirm(\n            'A group node with this name already exists embedded in this workflow, are you sure you want to overwrite it?'\n          )\n        ) {\n          return\n        }\n        break\n    }\n    return name\n  }\n\n  sortNodes() {\n    // Gets the builders nodes in graph execution order\n    const nodesInOrder = app.graph.computeExecutionOrder(false)\n    this.nodes = this.nodes\n      .map((node) => ({ index: nodesInOrder.indexOf(node), node }))\n      // @ts-expect-error id might be string\n      .sort((a, b) => a.index - b.index || a.node.id - b.node.id)\n      .map(({ node }) => node)\n  }\n\n  getNodeData() {\n    // @ts-expect-error fixme ts strict error\n    const storeLinkTypes = (config) => {\n      // Store link types for dynamically typed nodes e.g. reroutes\n      for (const link of config.links) {\n        const origin = app.graph.getNodeById(link[4])\n        // @ts-expect-error fixme ts strict error\n        const type = origin.outputs[link[1]].type\n        link.push(type)\n      }\n    }\n\n    // @ts-expect-error fixme ts strict error\n    const storeExternalLinks = (config) => {\n      // Store any external links to the group in the config so when rebuilding we add extra slots\n      config.external = []\n      for (let i = 0; i < this.nodes.length; i++) {\n        const node = this.nodes[i]\n        if (!node.outputs?.length) continue\n        for (let slot = 0; slot < node.outputs.length; slot++) {\n          let hasExternal = false\n          const output = node.outputs[slot]\n          let type = output.type\n          if (!output.links?.length) continue\n          for (const l of output.links) {\n            const link = app.graph.links[l]\n            if (!link) continue\n            if (type === '*') type = link.type\n\n            if (!app.canvas.selected_nodes[link.target_id]) {\n              hasExternal = true\n              break\n            }\n          }\n          if (hasExternal) {\n            config.external.push([i, slot, type])\n          }\n        }\n      }\n    }\n\n    // Use the built in copyToClipboard function to generate the node data we need\n    try {\n      // @ts-expect-error fixme ts strict error\n      const serialised = serialise(this.nodes, app.canvas.graph)\n      const config = JSON.parse(serialised)\n\n      storeLinkTypes(config)\n      storeExternalLinks(config)\n\n      return config\n    } finally {\n    }\n  }\n}\n\nexport class GroupNodeConfig {\n  name: string\n  nodeData: any\n  inputCount: number\n  oldToNewOutputMap: {}\n  newToOldOutputMap: {}\n  oldToNewInputMap: {}\n  oldToNewWidgetMap: {}\n  newToOldWidgetMap: {}\n  primitiveDefs: {}\n  widgetToPrimitive: {}\n  primitiveToWidget: {}\n  nodeInputs: {}\n  outputVisibility: any[]\n  // @ts-expect-error fixme ts strict error\n  nodeDef: ComfyNodeDef\n  // @ts-expect-error fixme ts strict error\n  inputs: any[]\n  // @ts-expect-error fixme ts strict error\n  linksFrom: {}\n  // @ts-expect-error fixme ts strict error\n  linksTo: {}\n  // @ts-expect-error fixme ts strict error\n  externalFrom: {}\n\n  // @ts-expect-error fixme ts strict error\n  constructor(name, nodeData) {\n    this.name = name\n    this.nodeData = nodeData\n    this.getLinks()\n\n    this.inputCount = 0\n    this.oldToNewOutputMap = {}\n    this.newToOldOutputMap = {}\n    this.oldToNewInputMap = {}\n    this.oldToNewWidgetMap = {}\n    this.newToOldWidgetMap = {}\n    this.primitiveDefs = {}\n    this.widgetToPrimitive = {}\n    this.primitiveToWidget = {}\n    this.nodeInputs = {}\n    this.outputVisibility = []\n  }\n\n  async registerType(source = PREFIX) {\n    this.nodeDef = {\n      output: [],\n      output_name: [],\n      output_is_list: [],\n      // @ts-expect-error Unused, doesn't exist\n      output_is_hidden: [],\n      name: source + SEPARATOR + this.name,\n      display_name: this.name,\n      category: 'group nodes' + (SEPARATOR + source),\n      input: { required: {} },\n      description: `Group node combining ${this.nodeData.nodes\n        // @ts-expect-error fixme ts strict error\n        .map((n) => n.type)\n        .join(', ')}`,\n      python_module: 'custom_nodes.' + this.name,\n\n      [GROUP]: this\n    }\n\n    this.inputs = []\n    const seenInputs = {}\n    const seenOutputs = {}\n    for (let i = 0; i < this.nodeData.nodes.length; i++) {\n      const node = this.nodeData.nodes[i]\n      node.index = i\n      this.processNode(node, seenInputs, seenOutputs)\n    }\n\n    for (const p of this.#convertedToProcess) {\n      // @ts-expect-error fixme ts strict error\n      p()\n    }\n    // @ts-expect-error fixme ts strict error\n    this.#convertedToProcess = null\n    await app.registerNodeDef(`${PREFIX}${SEPARATOR}` + this.name, this.nodeDef)\n    useNodeDefStore().addNodeDef(this.nodeDef)\n  }\n\n  getLinks() {\n    this.linksFrom = {}\n    this.linksTo = {}\n    this.externalFrom = {}\n\n    // Extract links for easy lookup\n    for (const l of this.nodeData.links) {\n      const [sourceNodeId, sourceNodeSlot, targetNodeId, targetNodeSlot] = l\n\n      // Skip links outside the copy config\n      if (sourceNodeId == null) continue\n\n      // @ts-expect-error fixme ts strict error\n      if (!this.linksFrom[sourceNodeId]) {\n        // @ts-expect-error fixme ts strict error\n        this.linksFrom[sourceNodeId] = {}\n      }\n      // @ts-expect-error fixme ts strict error\n      if (!this.linksFrom[sourceNodeId][sourceNodeSlot]) {\n        // @ts-expect-error fixme ts strict error\n        this.linksFrom[sourceNodeId][sourceNodeSlot] = []\n      }\n      // @ts-expect-error fixme ts strict error\n      this.linksFrom[sourceNodeId][sourceNodeSlot].push(l)\n\n      // @ts-expect-error fixme ts strict error\n      if (!this.linksTo[targetNodeId]) {\n        // @ts-expect-error fixme ts strict error\n        this.linksTo[targetNodeId] = {}\n      }\n      // @ts-expect-error fixme ts strict error\n      this.linksTo[targetNodeId][targetNodeSlot] = l\n    }\n\n    if (this.nodeData.external) {\n      for (const ext of this.nodeData.external) {\n        // @ts-expect-error fixme ts strict error\n        if (!this.externalFrom[ext[0]]) {\n          // @ts-expect-error fixme ts strict error\n          this.externalFrom[ext[0]] = { [ext[1]]: ext[2] }\n        } else {\n          // @ts-expect-error fixme ts strict error\n          this.externalFrom[ext[0]][ext[1]] = ext[2]\n        }\n      }\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  processNode(node, seenInputs, seenOutputs) {\n    const def = this.getNodeDef(node)\n    if (!def) return\n\n    const inputs = { ...def.input?.required, ...def.input?.optional }\n\n    this.inputs.push(this.processNodeInputs(node, seenInputs, inputs))\n    if (def.output?.length) this.processNodeOutputs(node, seenOutputs, def)\n  }\n\n  // @ts-expect-error fixme ts strict error\n  getNodeDef(node) {\n    // @ts-expect-error fixme ts strict error\n    const def = globalDefs[node.type]\n    if (def) return def\n\n    // @ts-expect-error fixme ts strict error\n    const linksFrom = this.linksFrom[node.index]\n    if (node.type === 'PrimitiveNode') {\n      // Skip as its not linked\n      if (!linksFrom) return\n\n      let type = linksFrom['0'][0][5]\n      if (type === 'COMBO') {\n        // Use the array items\n        const source = node.outputs[0].widget.name\n        const fromTypeName = this.nodeData.nodes[linksFrom['0'][0][2]].type\n        // @ts-expect-error fixme ts strict error\n        const fromType = globalDefs[fromTypeName]\n        const input =\n          fromType.input.required[source] ?? fromType.input.optional[source]\n        type = input[0]\n      }\n\n      // @ts-expect-error fixme ts strict error\n      const def = (this.primitiveDefs[node.index] = {\n        input: {\n          required: {\n            value: [type, {}]\n          }\n        },\n        output: [type],\n        output_name: [],\n        output_is_list: []\n      })\n      return def\n    } else if (node.type === 'Reroute') {\n      // @ts-expect-error fixme ts strict error\n      const linksTo = this.linksTo[node.index]\n      // @ts-expect-error fixme ts strict error\n      if (linksTo && linksFrom && !this.externalFrom[node.index]?.[0]) {\n        // Being used internally\n        return null\n      }\n\n      let config = {}\n      let rerouteType = '*'\n      if (linksFrom) {\n        for (const [, , id, slot] of linksFrom['0']) {\n          const node = this.nodeData.nodes[id]\n          const input = node.inputs[slot]\n          if (rerouteType === '*') {\n            rerouteType = input.type\n          }\n          if (input.widget) {\n            // @ts-expect-error fixme ts strict error\n            const targetDef = globalDefs[node.type]\n            const targetWidget =\n              targetDef.input.required[input.widget.name] ??\n              targetDef.input.optional[input.widget.name]\n\n            const widget = [targetWidget[0], config]\n            const res = mergeIfValid(\n              {\n                // @ts-expect-error fixme ts strict error\n                widget\n              },\n              targetWidget,\n              false,\n              null,\n              widget\n            )\n            config = res?.customConfig ?? config\n          }\n        }\n      } else if (linksTo) {\n        const [id, slot] = linksTo['0']\n        rerouteType = this.nodeData.nodes[id].outputs[slot].type\n      } else {\n        // Reroute used as a pipe\n        for (const l of this.nodeData.links) {\n          if (l[2] === node.index) {\n            rerouteType = l[5]\n            break\n          }\n        }\n        if (rerouteType === '*') {\n          // Check for an external link\n          // @ts-expect-error fixme ts strict error\n          const t = this.externalFrom[node.index]?.[0]\n          if (t) {\n            rerouteType = t\n          }\n        }\n      }\n\n      // @ts-expect-error\n      config.forceInput = true\n      return {\n        input: {\n          required: {\n            [rerouteType]: [rerouteType, config]\n          }\n        },\n        output: [rerouteType],\n        output_name: [],\n        output_is_list: []\n      }\n    }\n\n    console.warn(\n      'Skipping virtual node ' +\n        node.type +\n        ' when building group node ' +\n        this.name\n    )\n  }\n\n  // @ts-expect-error fixme ts strict error\n  getInputConfig(node, inputName, seenInputs, config, extra?) {\n    const customConfig = this.nodeData.config?.[node.index]?.input?.[inputName]\n    let name =\n      customConfig?.name ??\n      // @ts-expect-error fixme ts strict error\n      node.inputs?.find((inp) => inp.name === inputName)?.label ??\n      inputName\n    let key = name\n    let prefix = ''\n    // Special handling for primitive to include the title if it is set rather than just \"value\"\n    if ((node.type === 'PrimitiveNode' && node.title) || name in seenInputs) {\n      prefix = `${node.title ?? node.type} `\n      key = name = `${prefix}${inputName}`\n      if (name in seenInputs) {\n        name = `${prefix}${seenInputs[name]} ${inputName}`\n      }\n    }\n    seenInputs[key] = (seenInputs[key] ?? 1) + 1\n\n    if (inputName === 'seed' || inputName === 'noise_seed') {\n      if (!extra) extra = {}\n      extra.control_after_generate = `${prefix}control_after_generate`\n    }\n    if (config[0] === 'IMAGEUPLOAD') {\n      if (!extra) extra = {}\n      extra.widget =\n        // @ts-expect-error fixme ts strict error\n        this.oldToNewWidgetMap[node.index]?.[config[1]?.widget ?? 'image'] ??\n        'image'\n    }\n\n    if (extra) {\n      config = [config[0], { ...config[1], ...extra }]\n    }\n\n    return { name, config, customConfig }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  processWidgetInputs(inputs, node, inputNames, seenInputs) {\n    const slots = []\n    const converted = new Map()\n    // @ts-expect-error fixme ts strict error\n    const widgetMap = (this.oldToNewWidgetMap[node.index] = {})\n    for (const inputName of inputNames) {\n      if (useWidgetStore().inputIsWidget(inputs[inputName])) {\n        const convertedIndex = node.inputs?.findIndex(\n          // @ts-expect-error fixme ts strict error\n          (inp) => inp.name === inputName && inp.widget?.name === inputName\n        )\n        if (convertedIndex > -1) {\n          // This widget has been converted to a widget\n          // We need to store this in the correct position so link ids line up\n          converted.set(convertedIndex, inputName)\n          // @ts-expect-error fixme ts strict error\n          widgetMap[inputName] = null\n        } else {\n          // Normal widget\n          const { name, config } = this.getInputConfig(\n            node,\n            inputName,\n            seenInputs,\n            inputs[inputName]\n          )\n          // @ts-expect-error fixme ts strict error\n          this.nodeDef.input.required[name] = config\n          // @ts-expect-error fixme ts strict error\n          widgetMap[inputName] = name\n          // @ts-expect-error fixme ts strict error\n          this.newToOldWidgetMap[name] = { node, inputName }\n        }\n      } else {\n        // Normal input\n        slots.push(inputName)\n      }\n    }\n    return { converted, slots }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  checkPrimitiveConnection(link, inputName, inputs) {\n    const sourceNode = this.nodeData.nodes[link[0]]\n    if (sourceNode.type === 'PrimitiveNode') {\n      // Merge link configurations\n      const [sourceNodeId, _, targetNodeId, __] = link\n      // @ts-expect-error fixme ts strict error\n      const primitiveDef = this.primitiveDefs[sourceNodeId]\n      const targetWidget = inputs[inputName]\n      const primitiveConfig = primitiveDef.input.required.value\n      const output = { widget: primitiveConfig }\n      const config = mergeIfValid(\n        // @ts-expect-error invalid slot type\n        output,\n        targetWidget,\n        false,\n        null,\n        primitiveConfig\n      )\n      primitiveConfig[1] =\n        config?.customConfig ?? inputs[inputName][1]\n          ? { ...inputs[inputName][1] }\n          : {}\n\n      // @ts-expect-error fixme ts strict error\n      let name = this.oldToNewWidgetMap[sourceNodeId]['value']\n      name = name.substr(0, name.length - 6)\n      primitiveConfig[1].control_after_generate = true\n      primitiveConfig[1].control_prefix = name\n\n      // @ts-expect-error fixme ts strict error\n      let toPrimitive = this.widgetToPrimitive[targetNodeId]\n      if (!toPrimitive) {\n        // @ts-expect-error fixme ts strict error\n        toPrimitive = this.widgetToPrimitive[targetNodeId] = {}\n      }\n      if (toPrimitive[inputName]) {\n        toPrimitive[inputName].push(sourceNodeId)\n      }\n      toPrimitive[inputName] = sourceNodeId\n\n      // @ts-expect-error fixme ts strict error\n      let toWidget = this.primitiveToWidget[sourceNodeId]\n      if (!toWidget) {\n        // @ts-expect-error fixme ts strict error\n        toWidget = this.primitiveToWidget[sourceNodeId] = []\n      }\n      toWidget.push({ nodeId: targetNodeId, inputName })\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  processInputSlots(inputs, node, slots, linksTo, inputMap, seenInputs) {\n    // @ts-expect-error fixme ts strict error\n    this.nodeInputs[node.index] = {}\n    for (let i = 0; i < slots.length; i++) {\n      const inputName = slots[i]\n      if (linksTo[i]) {\n        this.checkPrimitiveConnection(linksTo[i], inputName, inputs)\n        // This input is linked so we can skip it\n        continue\n      }\n\n      const { name, config, customConfig } = this.getInputConfig(\n        node,\n        inputName,\n        seenInputs,\n        inputs[inputName]\n      )\n\n      // @ts-expect-error fixme ts strict error\n      this.nodeInputs[node.index][inputName] = name\n      if (customConfig?.visible === false) continue\n\n      // @ts-expect-error fixme ts strict error\n      this.nodeDef.input.required[name] = config\n      inputMap[i] = this.inputCount++\n    }\n  }\n\n  processConvertedWidgets(\n    // @ts-expect-error fixme ts strict error\n    inputs,\n    // @ts-expect-error fixme ts strict error\n    node,\n    // @ts-expect-error fixme ts strict error\n    slots,\n    // @ts-expect-error fixme ts strict error\n    converted,\n    // @ts-expect-error fixme ts strict error\n    linksTo,\n    // @ts-expect-error fixme ts strict error\n    inputMap,\n    // @ts-expect-error fixme ts strict error\n    seenInputs\n  ) {\n    // Add converted widgets sorted into their index order (ordered as they were converted) so link ids match up\n    const convertedSlots = [...converted.keys()]\n      .sort()\n      .map((k) => converted.get(k))\n    for (let i = 0; i < convertedSlots.length; i++) {\n      const inputName = convertedSlots[i]\n      if (linksTo[slots.length + i]) {\n        this.checkPrimitiveConnection(\n          linksTo[slots.length + i],\n          inputName,\n          inputs\n        )\n        // This input is linked so we can skip it\n        continue\n      }\n\n      const { name, config } = this.getInputConfig(\n        node,\n        inputName,\n        seenInputs,\n        inputs[inputName],\n        {\n          defaultInput: true\n        }\n      )\n\n      // @ts-expect-error fixme ts strict error\n      this.nodeDef.input.required[name] = config\n      // @ts-expect-error fixme ts strict error\n      this.newToOldWidgetMap[name] = { node, inputName }\n\n      // @ts-expect-error fixme ts strict error\n      if (!this.oldToNewWidgetMap[node.index]) {\n        // @ts-expect-error fixme ts strict error\n        this.oldToNewWidgetMap[node.index] = {}\n      }\n      // @ts-expect-error fixme ts strict error\n      this.oldToNewWidgetMap[node.index][inputName] = name\n\n      inputMap[slots.length + i] = this.inputCount++\n    }\n  }\n\n  #convertedToProcess = []\n  // @ts-expect-error fixme ts strict error\n  processNodeInputs(node, seenInputs, inputs) {\n    // @ts-expect-error fixme ts strict error\n    const inputMapping = []\n\n    const inputNames = Object.keys(inputs)\n    if (!inputNames.length) return\n\n    const { converted, slots } = this.processWidgetInputs(\n      inputs,\n      node,\n      inputNames,\n      seenInputs\n    )\n    // @ts-expect-error fixme ts strict error\n    const linksTo = this.linksTo[node.index] ?? {}\n    // @ts-expect-error fixme ts strict error\n    const inputMap = (this.oldToNewInputMap[node.index] = {})\n    this.processInputSlots(inputs, node, slots, linksTo, inputMap, seenInputs)\n\n    // Converted inputs have to be processed after all other nodes as they'll be at the end of the list\n    // @ts-expect-error fixme ts strict error\n    this.#convertedToProcess.push(() =>\n      this.processConvertedWidgets(\n        inputs,\n        node,\n        slots,\n        converted,\n        linksTo,\n        inputMap,\n        seenInputs\n      )\n    )\n\n    // @ts-expect-error fixme ts strict error\n    return inputMapping\n  }\n\n  // @ts-expect-error fixme ts strict error\n  processNodeOutputs(node, seenOutputs, def) {\n    // @ts-expect-error fixme ts strict error\n    const oldToNew = (this.oldToNewOutputMap[node.index] = {})\n\n    // Add outputs\n    for (let outputId = 0; outputId < def.output.length; outputId++) {\n      // @ts-expect-error fixme ts strict error\n      const linksFrom = this.linksFrom[node.index]\n      // If this output is linked internally we flag it to hide\n      const hasLink =\n        // @ts-expect-error fixme ts strict error\n        linksFrom?.[outputId] && !this.externalFrom[node.index]?.[outputId]\n      const customConfig =\n        this.nodeData.config?.[node.index]?.output?.[outputId]\n      const visible = customConfig?.visible ?? !hasLink\n      this.outputVisibility.push(visible)\n      if (!visible) {\n        continue\n      }\n\n      // @ts-expect-error fixme ts strict error\n      oldToNew[outputId] = this.nodeDef.output.length\n      // @ts-expect-error fixme ts strict error\n      this.newToOldOutputMap[this.nodeDef.output.length] = {\n        node,\n        slot: outputId\n      }\n      // @ts-expect-error fixme ts strict error\n      this.nodeDef.output.push(def.output[outputId])\n      // @ts-expect-error fixme ts strict error\n      this.nodeDef.output_is_list.push(def.output_is_list[outputId])\n\n      let label = customConfig?.name\n      if (!label) {\n        label = def.output_name?.[outputId] ?? def.output[outputId]\n        // @ts-expect-error fixme ts strict error\n        const output = node.outputs.find((o) => o.name === label)\n        if (output?.label) {\n          label = output.label\n        }\n      }\n\n      let name = label\n      if (name in seenOutputs) {\n        const prefix = `${node.title ?? node.type} `\n        name = `${prefix}${label}`\n        if (name in seenOutputs) {\n          name = `${prefix}${node.index} ${label}`\n        }\n      }\n      seenOutputs[name] = 1\n\n      // @ts-expect-error fixme ts strict error\n      this.nodeDef.output_name.push(name)\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  static async registerFromWorkflow(groupNodes, missingNodeTypes) {\n    for (const g in groupNodes) {\n      const groupData = groupNodes[g]\n\n      let hasMissing = false\n      for (const n of groupData.nodes) {\n        // Find missing node types\n        if (!(n.type in LiteGraph.registered_node_types)) {\n          missingNodeTypes.push({\n            type: n.type,\n            hint: ` (In group node '${PREFIX}${SEPARATOR}${g}')`\n          })\n\n          missingNodeTypes.push({\n            type: `${PREFIX}${SEPARATOR}` + g,\n            action: {\n              text: 'Remove from workflow',\n              // @ts-expect-error fixme ts strict error\n              callback: (e) => {\n                delete groupNodes[g]\n                e.target.textContent = 'Removed'\n                e.target.style.pointerEvents = 'none'\n                e.target.style.opacity = 0.7\n              }\n            }\n          })\n\n          hasMissing = true\n        }\n      }\n\n      if (hasMissing) continue\n\n      const config = new GroupNodeConfig(g, groupData)\n      await config.registerType()\n    }\n  }\n}\n\nexport class GroupNodeHandler {\n  node: LGraphNode\n  groupData: any\n  innerNodes: any\n\n  constructor(node: LGraphNode) {\n    this.node = node\n    this.groupData = node.constructor?.nodeData?.[GROUP]\n\n    this.node.setInnerNodes = (innerNodes) => {\n      this.innerNodes = innerNodes\n\n      for (\n        let innerNodeIndex = 0;\n        innerNodeIndex < this.innerNodes.length;\n        innerNodeIndex++\n      ) {\n        const innerNode = this.innerNodes[innerNodeIndex]\n        innerNode.graph ??= this.node.graph\n\n        for (const w of innerNode.widgets ?? []) {\n          if (w.type === 'converted-widget') {\n            w.serializeValue = w.origSerializeValue\n          }\n        }\n\n        innerNode.index = innerNodeIndex\n        // @ts-expect-error fixme ts strict error\n        innerNode.getInputNode = (slot) => {\n          // Check if this input is internal or external\n          const externalSlot =\n            this.groupData.oldToNewInputMap[innerNode.index]?.[slot]\n          if (externalSlot != null) {\n            return this.node.getInputNode(externalSlot)\n          }\n\n          // Internal link\n          const innerLink = this.groupData.linksTo[innerNode.index]?.[slot]\n          if (!innerLink) return null\n\n          const inputNode = innerNodes[innerLink[0]]\n          // Primitives will already apply their values\n          if (inputNode.type === 'PrimitiveNode') return null\n\n          return inputNode\n        }\n\n        // @ts-expect-error fixme ts strict error\n        innerNode.getInputLink = (slot) => {\n          const externalSlot =\n            this.groupData.oldToNewInputMap[innerNode.index]?.[slot]\n          if (externalSlot != null) {\n            // The inner node is connected via the group node inputs\n            const linkId = this.node.inputs[externalSlot].link\n            // @ts-expect-error fixme ts strict error\n            let link = app.graph.links[linkId]\n\n            // Use the outer link, but update the target to the inner node\n            link = {\n              ...link,\n              target_id: innerNode.id,\n              target_slot: +slot\n            }\n            return link\n          }\n\n          let link = this.groupData.linksTo[innerNode.index]?.[slot]\n          if (!link) return null\n          // Use the inner link, but update the origin node to be inner node id\n          link = {\n            origin_id: innerNodes[link[0]].id,\n            origin_slot: link[1],\n            target_id: innerNode.id,\n            target_slot: +slot\n          }\n          return link\n        }\n      }\n    }\n\n    this.node.updateLink = (link) => {\n      // Replace the group node reference with the internal node\n      // @ts-expect-error Can this be removed?  Or replaced with: LLink.create(link.asSerialisable())\n      link = { ...link }\n      const output = this.groupData.newToOldOutputMap[link.origin_slot]\n      let innerNode = this.innerNodes[output.node.index]\n      let l\n      while (innerNode?.type === 'Reroute') {\n        l = innerNode.getInputLink(0)\n        innerNode = innerNode.getInputNode(0)\n      }\n\n      if (!innerNode) {\n        return null\n      }\n\n      if (l && GroupNodeHandler.isGroupNode(innerNode)) {\n        return innerNode.updateLink(l)\n      }\n\n      link.origin_id = innerNode.id\n      link.origin_slot = l?.origin_slot ?? output.slot\n      return link\n    }\n\n    /** @internal Used to flatten the subgraph before execution. Recursive; call with no args. */\n    this.node.getInnerNodes = (\n      computedNodeDtos: Map<ExecutionId, ExecutableLGraphNode>,\n      /** The path of subgraph node IDs. */\n      subgraphNodePath: readonly NodeId[] = [],\n      /** The list of nodes to add to. */\n      nodes: ExecutableLGraphNode[] = [],\n      /** The set of visited nodes. */\n      visited = new Set<LGraphNode>()\n    ): ExecutableLGraphNode[] => {\n      if (visited.has(this.node))\n        throw new Error('RecursionError: while flattening subgraph')\n      visited.add(this.node)\n\n      if (!this.innerNodes) {\n        // @ts-expect-error fixme ts strict error\n        this.node.setInnerNodes(\n          // @ts-expect-error fixme ts strict error\n          this.groupData.nodeData.nodes.map((n, i) => {\n            const innerNode = LiteGraph.createNode(n.type)\n            // @ts-expect-error fixme ts strict error\n            innerNode.configure(n)\n            // @ts-expect-error fixme ts strict error\n            innerNode.id = `${this.node.id}:${i}`\n            // @ts-expect-error fixme ts strict error\n            innerNode.graph = this.node.graph\n            return innerNode\n          })\n        )\n      }\n\n      this.updateInnerWidgets()\n\n      const subgraphInstanceIdPath = [...subgraphNodePath, this.node.id]\n\n      // Assertion: Deprecated, does not matter.\n      const subgraphNode = (this.node.graph?.getNodeById(\n        subgraphNodePath.at(-1)\n      ) ?? undefined) as SubgraphNode | undefined\n\n      for (const node of this.innerNodes) {\n        node.graph ??= this.node.graph\n\n        // Create minimal DTOs rather than cloning the node\n        const currentId = String(node.id)\n        node.id = currentId.split(':').at(-1)\n        const aVeryRealNode = new ExecutableGroupNodeChildDTO(\n          node,\n          subgraphInstanceIdPath,\n          computedNodeDtos,\n          subgraphNode\n        )\n        node.id = currentId\n        aVeryRealNode.groupNodeHandler = this\n\n        nodes.push(aVeryRealNode)\n      }\n      return nodes\n    }\n\n    // @ts-expect-error fixme ts strict error\n    this.node.recreate = async () => {\n      const id = this.node.id\n      const sz = this.node.size\n      // @ts-expect-error fixme ts strict error\n      const nodes = this.node.convertToNodes()\n\n      const groupNode = LiteGraph.createNode(this.node.type)\n      // @ts-expect-error fixme ts strict error\n      groupNode.id = id\n\n      // Reuse the existing nodes for this instance\n      // @ts-expect-error fixme ts strict error\n      groupNode.setInnerNodes(nodes)\n      // @ts-expect-error fixme ts strict error\n      groupNode[GROUP].populateWidgets()\n      // @ts-expect-error fixme ts strict error\n      app.graph.add(groupNode)\n      // @ts-expect-error fixme ts strict error\n      groupNode.setSize([\n        // @ts-expect-error fixme ts strict error\n        Math.max(groupNode.size[0], sz[0]),\n        // @ts-expect-error fixme ts strict error\n        Math.max(groupNode.size[1], sz[1])\n      ])\n\n      // Remove all converted nodes and relink them\n      const builder = new GroupNodeBuilder(nodes)\n      const nodeData = builder.getNodeData()\n      // @ts-expect-error fixme ts strict error\n      groupNode[GROUP].groupData.nodeData.links = nodeData.links\n      // @ts-expect-error fixme ts strict error\n      groupNode[GROUP].replaceNodes(nodes)\n      return groupNode\n    }\n\n    // @ts-expect-error fixme ts strict error\n    this.node.convertToNodes = () => {\n      const addInnerNodes = () => {\n        // Clone the node data so we dont mutate it for other nodes\n        const c = { ...this.groupData.nodeData }\n        c.nodes = [...c.nodes]\n        // @ts-expect-error fixme ts strict error\n        const innerNodes = this.node.getInnerNodes()\n        let ids = []\n        for (let i = 0; i < c.nodes.length; i++) {\n          let id = innerNodes?.[i]?.id\n          // Use existing IDs if they are set on the inner nodes\n          // @ts-expect-error id can be string or number\n          if (id == null || isNaN(id)) {\n            // @ts-expect-error fixme ts strict error\n            id = undefined\n          } else {\n            ids.push(id)\n          }\n          c.nodes[i] = { ...c.nodes[i], id }\n        }\n        deserialiseAndCreate(JSON.stringify(c), app.canvas)\n\n        const [x, y] = this.node.pos\n        let top\n        let left\n        // Configure nodes with current widget data\n        const selectedIds = ids.length\n          ? ids\n          : Object.keys(app.canvas.selected_nodes)\n        const newNodes = []\n        for (let i = 0; i < selectedIds.length; i++) {\n          const id = selectedIds[i]\n          const newNode = app.graph.getNodeById(id)\n          const innerNode = innerNodes[i]\n          newNodes.push(newNode)\n\n          // @ts-expect-error fixme ts strict error\n          if (left == null || newNode.pos[0] < left) {\n            // @ts-expect-error fixme ts strict error\n            left = newNode.pos[0]\n          }\n          // @ts-expect-error fixme ts strict error\n          if (top == null || newNode.pos[1] < top) {\n            // @ts-expect-error fixme ts strict error\n            top = newNode.pos[1]\n          }\n\n          // @ts-expect-error fixme ts strict error\n          if (!newNode.widgets) continue\n\n          // @ts-expect-error fixme ts strict error\n          const map = this.groupData.oldToNewWidgetMap[innerNode.index]\n          if (map) {\n            const widgets = Object.keys(map)\n\n            for (const oldName of widgets) {\n              const newName = map[oldName]\n              if (!newName) continue\n\n              // @ts-expect-error fixme ts strict error\n              const widgetIndex = this.node.widgets.findIndex(\n                (w) => w.name === newName\n              )\n              if (widgetIndex === -1) continue\n\n              // Populate the main and any linked widgets\n              if (innerNode.type === 'PrimitiveNode') {\n                // @ts-expect-error fixme ts strict error\n                for (let i = 0; i < newNode.widgets.length; i++) {\n                  // @ts-expect-error fixme ts strict error\n                  newNode.widgets[i].value =\n                    // @ts-expect-error fixme ts strict error\n                    this.node.widgets[widgetIndex + i].value\n                }\n              } else {\n                // @ts-expect-error fixme ts strict error\n                const outerWidget = this.node.widgets[widgetIndex]\n                // @ts-expect-error fixme ts strict error\n                const newWidget = newNode.widgets.find(\n                  (w) => w.name === oldName\n                )\n                if (!newWidget) continue\n\n                newWidget.value = outerWidget.value\n                // @ts-expect-error fixme ts strict error\n                for (let w = 0; w < outerWidget.linkedWidgets?.length; w++) {\n                  // @ts-expect-error fixme ts strict error\n                  newWidget.linkedWidgets[w].value =\n                    // @ts-expect-error fixme ts strict error\n                    outerWidget.linkedWidgets[w].value\n                }\n              }\n            }\n          }\n        }\n\n        // Shift each node\n        for (const newNode of newNodes) {\n          // @ts-expect-error fixme ts strict error\n          newNode.pos[0] -= left - x\n          // @ts-expect-error fixme ts strict error\n          newNode.pos[1] -= top - y\n        }\n\n        return { newNodes, selectedIds }\n      }\n\n      // @ts-expect-error fixme ts strict error\n      const reconnectInputs = (selectedIds) => {\n        for (const innerNodeIndex in this.groupData.oldToNewInputMap) {\n          const id = selectedIds[innerNodeIndex]\n          const newNode = app.graph.getNodeById(id)\n          const map = this.groupData.oldToNewInputMap[innerNodeIndex]\n          for (const innerInputId in map) {\n            const groupSlotId = map[innerInputId]\n            if (groupSlotId == null) continue\n            const slot = node.inputs[groupSlotId]\n            if (slot.link == null) continue\n            const link = app.graph.links[slot.link]\n            if (!link) continue\n            //  connect this node output to the input of another node\n            const originNode = app.graph.getNodeById(link.origin_id)\n            // @ts-expect-error fixme ts strict error\n            originNode.connect(link.origin_slot, newNode, +innerInputId)\n          }\n        }\n      }\n\n      // @ts-expect-error fixme ts strict error\n      const reconnectOutputs = (selectedIds) => {\n        for (\n          let groupOutputId = 0;\n          groupOutputId < node.outputs?.length;\n          groupOutputId++\n        ) {\n          const output = node.outputs[groupOutputId]\n          if (!output.links) continue\n          const links = [...output.links]\n          for (const l of links) {\n            const slot = this.groupData.newToOldOutputMap[groupOutputId]\n            const link = app.graph.links[l]\n            const targetNode = app.graph.getNodeById(link.target_id)\n            const newNode = app.graph.getNodeById(selectedIds[slot.node.index])\n            // @ts-expect-error fixme ts strict error\n            newNode.connect(slot.slot, targetNode, link.target_slot)\n          }\n        }\n      }\n\n      app.canvas.emitBeforeChange()\n\n      try {\n        const { newNodes, selectedIds } = addInnerNodes()\n        reconnectInputs(selectedIds)\n        reconnectOutputs(selectedIds)\n        app.graph.remove(this.node)\n\n        return newNodes\n      } finally {\n        app.canvas.emitAfterChange()\n      }\n    }\n\n    const getExtraMenuOptions = this.node.getExtraMenuOptions\n    // @ts-expect-error Should pass patched return value getExtraMenuOptions\n    this.node.getExtraMenuOptions = function (_, options) {\n      // @ts-expect-error fixme ts strict error\n      getExtraMenuOptions?.apply(this, arguments)\n\n      // @ts-expect-error fixme ts strict error\n      let optionIndex = options.findIndex((o) => o.content === 'Outputs')\n      if (optionIndex === -1) optionIndex = options.length\n      else optionIndex++\n      options.splice(\n        optionIndex,\n        0,\n        null,\n        {\n          content: 'Convert to nodes',\n          // @ts-expect-error\n          callback: () => {\n            // @ts-expect-error fixme ts strict error\n            return this.convertToNodes()\n          }\n        },\n        {\n          content: 'Manage Group Node',\n          callback: () => manageGroupNodes(this.type)\n        }\n      )\n    }\n\n    // Draw custom collapse icon to identity this as a group\n    const onDrawTitleBox = this.node.onDrawTitleBox\n    this.node.onDrawTitleBox = function (ctx, height) {\n      // @ts-expect-error fixme ts strict error\n      onDrawTitleBox?.apply(this, arguments)\n\n      const fill = ctx.fillStyle\n      ctx.beginPath()\n      ctx.rect(11, -height + 11, 2, 2)\n      ctx.rect(14, -height + 11, 2, 2)\n      ctx.rect(17, -height + 11, 2, 2)\n      ctx.rect(11, -height + 14, 2, 2)\n      ctx.rect(14, -height + 14, 2, 2)\n      ctx.rect(17, -height + 14, 2, 2)\n      ctx.rect(11, -height + 17, 2, 2)\n      ctx.rect(14, -height + 17, 2, 2)\n      ctx.rect(17, -height + 17, 2, 2)\n\n      ctx.fillStyle = this.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR\n      ctx.fill()\n      ctx.fillStyle = fill\n    }\n\n    // Draw progress label\n    const onDrawForeground = node.onDrawForeground\n    const groupData = this.groupData.nodeData\n    node.onDrawForeground = function (ctx) {\n      // @ts-expect-error fixme ts strict error\n      onDrawForeground?.apply?.(this, arguments)\n      if (\n        // @ts-expect-error fixme ts strict error\n        +app.runningNodeId === this.id &&\n        this.runningInternalNodeId !== null\n      ) {\n        // @ts-expect-error fixme ts strict error\n        const n = groupData.nodes[this.runningInternalNodeId]\n        if (!n) return\n        const message = `Running ${n.title || n.type} (${this.runningInternalNodeId}/${groupData.nodes.length})`\n        ctx.save()\n        ctx.font = '12px sans-serif'\n        const sz = ctx.measureText(message)\n        ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR\n        ctx.beginPath()\n        ctx.roundRect(\n          0,\n          -LiteGraph.NODE_TITLE_HEIGHT - 20,\n          sz.width + 12,\n          20,\n          5\n        )\n        ctx.fill()\n\n        ctx.fillStyle = '#fff'\n        ctx.fillText(message, 6, -LiteGraph.NODE_TITLE_HEIGHT - 6)\n        ctx.restore()\n      }\n    }\n\n    // Flag this node as needing to be reset\n    const onExecutionStart = this.node.onExecutionStart\n    this.node.onExecutionStart = function () {\n      // @ts-expect-error fixme ts strict error\n      this.resetExecution = true\n      // @ts-expect-error fixme ts strict error\n      return onExecutionStart?.apply(this, arguments)\n    }\n\n    const self = this\n    const onNodeCreated = this.node.onNodeCreated\n    this.node.onNodeCreated = function () {\n      if (!this.widgets) {\n        return\n      }\n      const config = self.groupData.nodeData.config\n      if (config) {\n        for (const n in config) {\n          const inputs = config[n]?.input\n          for (const w in inputs) {\n            if (inputs[w].visible !== false) continue\n            const widgetName = self.groupData.oldToNewWidgetMap[n][w]\n            const widget = this.widgets.find((w) => w.name === widgetName)\n            if (widget) {\n              widget.type = 'hidden'\n              widget.computeSize = () => [0, -4]\n            }\n          }\n        }\n      }\n\n      // @ts-expect-error fixme ts strict error\n      return onNodeCreated?.apply(this, arguments)\n    }\n\n    // @ts-expect-error fixme ts strict error\n    function handleEvent(type, getId, getEvent) {\n      // @ts-expect-error fixme ts strict error\n      const handler = ({ detail }) => {\n        const id = getId(detail)\n        if (!id) return\n        const node = app.graph.getNodeById(id)\n        if (node) return\n\n        // @ts-expect-error fixme ts strict error\n        const innerNodeIndex = this.innerNodes?.findIndex((n) => n.id == id)\n        if (innerNodeIndex > -1) {\n          // @ts-expect-error fixme ts strict error\n          this.node.runningInternalNodeId = innerNodeIndex\n          api.dispatchCustomEvent(\n            type,\n            // @ts-expect-error fixme ts strict error\n            getEvent(detail, `${this.node.id}`, this.node)\n          )\n        }\n      }\n      api.addEventListener(type, handler)\n      return handler\n    }\n\n    const executing = handleEvent.call(\n      this,\n      'executing',\n      // @ts-expect-error fixme ts strict error\n      (d) => d,\n      // @ts-expect-error fixme ts strict error\n      (_, id) => id\n    )\n\n    const executed = handleEvent.call(\n      this,\n      'executed',\n      // @ts-expect-error fixme ts strict error\n      (d) => d?.display_node || d?.node,\n      // @ts-expect-error fixme ts strict error\n      (d, id, node) => ({\n        ...d,\n        node: id,\n        display_node: id,\n        merge: !node.resetExecution\n      })\n    )\n\n    const onRemoved = node.onRemoved\n    this.node.onRemoved = function () {\n      // @ts-expect-error fixme ts strict error\n      onRemoved?.apply(this, arguments)\n      api.removeEventListener('executing', executing)\n      api.removeEventListener('executed', executed)\n    }\n\n    this.node.refreshComboInNode = (defs) => {\n      // Update combo widget options\n      for (const widgetName in this.groupData.newToOldWidgetMap) {\n        // @ts-expect-error fixme ts strict error\n        const widget = this.node.widgets.find((w) => w.name === widgetName)\n        if (widget?.type === 'combo') {\n          const old = this.groupData.newToOldWidgetMap[widgetName]\n          const def = defs[old.node.type]\n          const input =\n            def?.input?.required?.[old.inputName] ??\n            def?.input?.optional?.[old.inputName]\n          if (!input) continue\n\n          widget.options.values = input[0]\n\n          if (\n            old.inputName !== 'image' &&\n            // @ts-expect-error Widget values\n            !widget.options.values.includes(widget.value)\n          ) {\n            // @ts-expect-error fixme ts strict error\n            widget.value = widget.options.values[0]\n            // @ts-expect-error fixme ts strict error\n            widget.callback(widget.value)\n          }\n        }\n      }\n    }\n  }\n\n  updateInnerWidgets() {\n    for (const newWidgetName in this.groupData.newToOldWidgetMap) {\n      // @ts-expect-error fixme ts strict error\n      const newWidget = this.node.widgets.find((w) => w.name === newWidgetName)\n      if (!newWidget) continue\n\n      const newValue = newWidget.value\n      const old = this.groupData.newToOldWidgetMap[newWidgetName]\n      let innerNode = this.innerNodes[old.node.index]\n\n      if (innerNode.type === 'PrimitiveNode') {\n        innerNode.primitiveValue = newValue\n        const primitiveLinked = this.groupData.primitiveToWidget[old.node.index]\n        for (const linked of primitiveLinked ?? []) {\n          const node = this.innerNodes[linked.nodeId]\n          // @ts-expect-error fixme ts strict error\n          const widget = node.widgets.find((w) => w.name === linked.inputName)\n\n          if (widget) {\n            widget.value = newValue\n          }\n        }\n        continue\n      } else if (innerNode.type === 'Reroute') {\n        const rerouteLinks = this.groupData.linksFrom[old.node.index]\n        if (rerouteLinks) {\n          for (const [_, , targetNodeId, targetSlot] of rerouteLinks['0']) {\n            const node = this.innerNodes[targetNodeId]\n            const input = node.inputs[targetSlot]\n            if (input.widget) {\n              const widget = node.widgets?.find(\n                // @ts-expect-error fixme ts strict error\n                (w) => w.name === input.widget.name\n              )\n              if (widget) {\n                widget.value = newValue\n              }\n            }\n          }\n        }\n      }\n\n      // @ts-expect-error fixme ts strict error\n      const widget = innerNode.widgets?.find((w) => w.name === old.inputName)\n      if (widget) {\n        widget.value = newValue\n      }\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  populatePrimitive(_node, nodeId, oldName) {\n    // Converted widget, populate primitive if linked\n    const primitiveId = this.groupData.widgetToPrimitive[nodeId]?.[oldName]\n    if (primitiveId == null) return\n    const targetWidgetName =\n      this.groupData.oldToNewWidgetMap[primitiveId]['value']\n    // @ts-expect-error fixme ts strict error\n    const targetWidgetIndex = this.node.widgets.findIndex(\n      (w) => w.name === targetWidgetName\n    )\n    if (targetWidgetIndex > -1) {\n      const primitiveNode = this.innerNodes[primitiveId]\n      let len = primitiveNode.widgets.length\n      if (\n        len - 1 !==\n        // @ts-expect-error fixme ts strict error\n        this.node.widgets[targetWidgetIndex].linkedWidgets?.length\n      ) {\n        // Fallback handling for if some reason the primitive has a different number of widgets\n        // we dont want to overwrite random widgets, better to leave blank\n        len = 1\n      }\n      for (let i = 0; i < len; i++) {\n        // @ts-expect-error fixme ts strict error\n        this.node.widgets[targetWidgetIndex + i].value =\n          primitiveNode.widgets[i].value\n      }\n    }\n    return true\n  }\n\n  // @ts-expect-error fixme ts strict error\n  populateReroute(node, nodeId, map) {\n    if (node.type !== 'Reroute') return\n\n    const link = this.groupData.linksFrom[nodeId]?.[0]?.[0]\n    if (!link) return\n    const [, , targetNodeId, targetNodeSlot] = link\n    const targetNode = this.groupData.nodeData.nodes[targetNodeId]\n    const inputs = targetNode.inputs\n    const targetWidget = inputs?.[targetNodeSlot]?.widget\n    if (!targetWidget) return\n\n    const offset = inputs.length - (targetNode.widgets_values?.length ?? 0)\n    const v = targetNode.widgets_values?.[targetNodeSlot - offset]\n    if (v == null) return\n\n    const widgetName = Object.values(map)[0]\n    // @ts-expect-error fixme ts strict error\n    const widget = this.node.widgets.find((w) => w.name === widgetName)\n    if (widget) {\n      widget.value = v\n    }\n  }\n\n  populateWidgets() {\n    if (!this.node.widgets) return\n\n    for (\n      let nodeId = 0;\n      nodeId < this.groupData.nodeData.nodes.length;\n      nodeId++\n    ) {\n      const node = this.groupData.nodeData.nodes[nodeId]\n      const map = this.groupData.oldToNewWidgetMap[nodeId] ?? {}\n      const widgets = Object.keys(map)\n\n      if (!node.widgets_values?.length) {\n        // special handling for populating values into reroutes\n        // this allows primitives connect to them to pick up the correct value\n        this.populateReroute(node, nodeId, map)\n        continue\n      }\n\n      let linkedShift = 0\n      for (let i = 0; i < widgets.length; i++) {\n        const oldName = widgets[i]\n        const newName = map[oldName]\n        const widgetIndex = this.node.widgets.findIndex(\n          (w) => w.name === newName\n        )\n        const mainWidget = this.node.widgets[widgetIndex]\n        if (\n          this.populatePrimitive(node, nodeId, oldName) ||\n          widgetIndex === -1\n        ) {\n          // Find the inner widget and shift by the number of linked widgets as they will have been removed too\n          const innerWidget = this.innerNodes[nodeId].widgets?.find(\n            // @ts-expect-error fixme ts strict error\n            (w) => w.name === oldName\n          )\n          linkedShift += innerWidget?.linkedWidgets?.length ?? 0\n        }\n        if (widgetIndex === -1) {\n          continue\n        }\n\n        // Populate the main and any linked widget\n        mainWidget.value = node.widgets_values[i + linkedShift]\n        // @ts-expect-error fixme ts strict error\n        for (let w = 0; w < mainWidget.linkedWidgets?.length; w++) {\n          this.node.widgets[widgetIndex + w + 1].value =\n            node.widgets_values[i + ++linkedShift]\n        }\n      }\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  replaceNodes(nodes) {\n    let top\n    let left\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i]\n      if (left == null || node.pos[0] < left) {\n        left = node.pos[0]\n      }\n      if (top == null || node.pos[1] < top) {\n        top = node.pos[1]\n      }\n\n      this.linkOutputs(node, i)\n      app.graph.remove(node)\n\n      // Set internal ID to what is expected after workflow is reloaded\n      node.id = `${this.node.id}:${i}`\n    }\n\n    this.linkInputs()\n    this.node.pos = [left, top]\n  }\n\n  // @ts-expect-error fixme ts strict error\n  linkOutputs(originalNode, nodeId) {\n    if (!originalNode.outputs) return\n\n    for (const output of originalNode.outputs) {\n      if (!output.links) continue\n      // Clone the links as they'll be changed if we reconnect\n      const links = [...output.links]\n      for (const l of links) {\n        const link = app.graph.links[l]\n        if (!link) continue\n\n        const targetNode = app.graph.getNodeById(link.target_id)\n        const newSlot =\n          this.groupData.oldToNewOutputMap[nodeId]?.[link.origin_slot]\n        if (newSlot != null) {\n          // @ts-expect-error fixme ts strict error\n          this.node.connect(newSlot, targetNode, link.target_slot)\n        }\n      }\n    }\n  }\n\n  linkInputs() {\n    for (const link of this.groupData.nodeData.links ?? []) {\n      const [, originSlot, targetId, targetSlot, actualOriginId] = link\n      const originNode = app.graph.getNodeById(actualOriginId)\n      if (!originNode) continue // this node is in the group\n      originNode.connect(\n        originSlot,\n        // @ts-expect-error Valid - uses deprecated interface.  Required check: if (graph.getNodeById(this.node.id) !== this.node) report()\n        this.node.id,\n        this.groupData.oldToNewInputMap[targetId][targetSlot]\n      )\n    }\n  }\n\n  // @ts-expect-error fixme ts strict error\n  static getGroupData(node) {\n    return (node.nodeData ?? node.constructor?.nodeData)?.[GROUP]\n  }\n\n  static isGroupNode(node: LGraphNode) {\n    return !!node.constructor?.nodeData?.[GROUP]\n  }\n\n  static async fromNodes(nodes: LGraphNode[]) {\n    // Process the nodes into the stored workflow group node data\n    const builder = new GroupNodeBuilder(nodes)\n    const res = await builder.build()\n    if (!res) return\n\n    const { name, nodeData } = res\n\n    // Convert this data into a LG node definition and register it\n    const config = new GroupNodeConfig(name, nodeData)\n    await config.registerType()\n\n    const groupNode = LiteGraph.createNode(`${PREFIX}${SEPARATOR}${name}`)\n    // Reuse the existing nodes for this instance\n    // @ts-expect-error fixme ts strict error\n    groupNode.setInnerNodes(builder.nodes)\n    // @ts-expect-error fixme ts strict error\n    groupNode[GROUP].populateWidgets()\n    // @ts-expect-error fixme ts strict error\n    app.graph.add(groupNode)\n\n    // Remove all converted nodes and relink them\n    // @ts-expect-error fixme ts strict error\n    groupNode[GROUP].replaceNodes(builder.nodes)\n    return groupNode\n  }\n}\n\nconst replaceLegacySeparators = (nodes: ComfyNode[]): void => {\n  for (const node of nodes) {\n    if (typeof node.type === 'string' && node.type.startsWith('workflow/')) {\n      node.type = node.type.replace(/^workflow\\//, `${PREFIX}${SEPARATOR}`)\n    }\n  }\n}\n\n/**\n * Convert selected nodes to a group node\n * @throws {Error} if no nodes are selected\n * @throws {Error} if a group node is already selected\n * @throws {Error} if a group node is selected\n *\n * The context menu item should not be available if any of the above conditions are met.\n * The error is automatically handled by the commandStore when the command is executed.\n */\nasync function convertSelectedNodesToGroupNode() {\n  const nodes = Object.values(app.canvas.selected_nodes ?? {})\n  if (nodes.length === 0) {\n    throw new Error('No nodes selected')\n  }\n  if (nodes.length === 1) {\n    throw new Error('Please select multiple nodes to convert to group node')\n  }\n\n  for (const node of nodes) {\n    if (node instanceof SubgraphNode) {\n      throw new Error('Selected nodes contain a subgraph node')\n    }\n    if (GroupNodeHandler.isGroupNode(node)) {\n      throw new Error('Selected nodes contain a group node')\n    }\n  }\n  return await GroupNodeHandler.fromNodes(nodes)\n}\n\nfunction ungroupSelectedGroupNodes() {\n  const nodes = Object.values(app.canvas.selected_nodes ?? {})\n  for (const node of nodes) {\n    if (GroupNodeHandler.isGroupNode(node)) {\n      node.convertToNodes?.()\n    }\n  }\n}\n\nfunction manageGroupNodes(type?: string) {\n  new ManageGroupDialog(app).show(type)\n}\n\nconst id = 'Comfy.GroupNode'\n// @ts-expect-error fixme ts strict error\nlet globalDefs\nconst ext: ComfyExtension = {\n  name: id,\n  commands: [\n    {\n      id: 'Comfy.GroupNode.ConvertSelectedNodesToGroupNode',\n      label: 'Convert selected nodes to group node',\n      icon: 'pi pi-sitemap',\n      versionAdded: '1.3.17',\n      function: convertSelectedNodesToGroupNode\n    },\n    {\n      id: 'Comfy.GroupNode.UngroupSelectedGroupNodes',\n      label: 'Ungroup selected group nodes',\n      icon: 'pi pi-sitemap',\n      versionAdded: '1.3.17',\n      function: ungroupSelectedGroupNodes\n    },\n    {\n      id: 'Comfy.GroupNode.ManageGroupNodes',\n      label: 'Manage group nodes',\n      icon: 'pi pi-cog',\n      versionAdded: '1.3.17',\n      function: manageGroupNodes\n    }\n  ],\n  keybindings: [\n    {\n      commandId: 'Comfy.GroupNode.ConvertSelectedNodesToGroupNode',\n      combo: {\n        alt: true,\n        key: 'g'\n      }\n    },\n    {\n      commandId: 'Comfy.GroupNode.UngroupSelectedGroupNodes',\n      combo: {\n        alt: true,\n        shift: true,\n        key: 'G'\n      }\n    }\n  ],\n  async beforeConfigureGraph(\n    graphData: ComfyWorkflowJSON,\n    missingNodeTypes: string[]\n  ) {\n    const nodes = graphData?.extra?.groupNodes\n    if (nodes) {\n      replaceLegacySeparators(graphData.nodes)\n      await GroupNodeConfig.registerFromWorkflow(nodes, missingNodeTypes)\n    }\n  },\n  addCustomNodeDefs(defs) {\n    // Store this so we can mutate it later with group nodes\n    globalDefs = defs\n  },\n  nodeCreated(node) {\n    if (GroupNodeHandler.isGroupNode(node)) {\n      // @ts-expect-error fixme ts strict error\n      node[GROUP] = new GroupNodeHandler(node)\n\n      // Ensure group nodes pasted from other workflows are stored\n      // @ts-expect-error fixme ts strict error\n      if (node.title && node[GROUP]?.groupData?.nodeData) {\n        // @ts-expect-error fixme ts strict error\n        Workflow.storeGroupNode(node.title, node[GROUP].groupData.nodeData)\n      }\n    }\n  },\n  // @ts-expect-error fixme ts strict error\n  async refreshComboInNodes(defs) {\n    // Re-register group nodes so new ones are created with the correct options\n    // @ts-expect-error fixme ts strict error\n    Object.assign(globalDefs, defs)\n    const nodes = app.graph.extra?.groupNodes\n    if (nodes) {\n      await GroupNodeConfig.registerFromWorkflow(nodes, {})\n    }\n  }\n}\n\napp.registerExtension(ext)\n"],"names":["id","PREFIX","SEPARATOR","app","type","t","ext","w","def","node","_","link","groupNode","i","widget"],"mappings":";;;AAWO,MAAM,oCAAoC,kBAAkB;AAAA,SAAA;AAAA;AAAA;AAAA,EACjE;AAAA,EAEA,YAEE,MAEA,kBAEA,oBAEA,cACA,kBACA;AACM,UAAA,MAAM,kBAAkB,oBAAoB,YAAY;AAC9D,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAES,aAAa,MAAc;AAClC,UAAM,YAAY,KAAK,KAAK,aAAa,IAAI;AAC7C,QAAI,CAAC,UAAW;AAEhB,UAAM,OAAO,KAAK,KAAK,aAAa,IAAI;AACxC,QAAI,CAAC,KAAY,OAAA,IAAI,MAAM,0BAA0B;AAE/C,UAAAA,MAAK,OAAO,UAAU,EAAE,EAAE,MAAM,GAAG,EAAE,GAAG,EAAE;AAChD,QAAIA,QAAO,OAAiB,OAAA,IAAI,MAAM,uBAAuB;AAE7D,UAAM,eAAe,KAAK,oBAAoB,IAAIA,GAAE;AACpD,QAAI,CAAC,cAAc;AACjB,YAAM,IAAI;AAAA,QACR,4BAA4BA,GAAE,yBAAyB,KAAK,EAAE,cAAc,IAAI;AAAA,MAAA;AAAA,IAEpF;AAEO,WAAA;AAAA,MACL,MAAM;AAAA,MACN,WAAW,OAAO,UAAU,EAAE;AAAA,MAC9B,aAAa,KAAK;AAAA,IAAA;AAAA,EAEtB;AACF;ACrCA,MAAM,QAAgB,OAAO;AAC7B,MAAMC,WAAS;AACf,MAAMC,cAAY;AAGlB,SAAS,MAAM,QAAQ,QAAQ;AAC7B,MAAI,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;AAC5D,eAAW,OAAO,QAAQ;AAClB,YAAA,KAAK,OAAO,GAAG;AACjB,UAAA,OAAO,OAAO,UAAU;AACtB,YAAA,KAAK,OAAO,GAAG;AACnB,YAAI,CAAC,GAAI,MAAK,OAAO,GAAG,IAAI,CAAA;AACtB,cAAA,IAAI,OAAO,GAAG,CAAC;AAAA,MAAA,OAChB;AACL,eAAO,GAAG,IAAI;AAAA,MAChB;AAAA,IACF;AAAA,EACF;AAEO,SAAA;AACT;AAfS;AAiBF,MAAM,0BAA0B,YAA+B;AAAA,SAAA;AAAA;AAAA;AAAA;AAAA,EAEpE;AAAA,EAIA;AAAA,EACA,cAA+C;AAAA,EAC/C;AAAA,EACA,gBASI,CAAA;AAAA;AAAA,EAEJ;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA,IAAI,yBAAyB;AAE3B,WAAO,CAAC,KAAK,UAAU,KAAK,iBAAiB,EAAE,QAAQ;AAAA,EACzD;AAAA;AAAA,EAGA,YAAYC,MAAK;AACT;AACN,SAAK,MAAMA;AACN,SAAA,UAAU,IAAI,6BAA6B;AAAA,MAC9C,QAAQ,SAAS;AAAA,IAAA,CAClB;AAAA,EACH;AAAA;AAAA,EAGA,UAAU,KAAK;AACb,SAAK,KAAK,KAAK,WAAW,EAAE,IAAI,UAAU,OAAO,QAAQ;AACzD,SAAK,KAAK,KAAK,WAAW,EAAE,KAAK,UAAU,OAAO,QAAQ;AAE1D,SAAK,KAAK,GAAG,EAAE,IAAI,UAAU,IAAI,QAAQ;AAEzC,SAAK,KAAK,GAAG,EAAE,KAAK,UAAU,IAAI,QAAQ;AAC1C,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA,EAGA,WAAW,OAAO,OAAQ;AACxB,QAAI,CAAC,SAAS,KAAK,sBAAsB,MAAO;AAE5C,QAAA,KAAK,qBAAqB,MAAM;AAClC,WAAK,UAAU,KAAK,iBAAiB,EAAE,UAAU,OAAO,UAAU;AAAA,IACpE;AACA,SAAK,UAAU,KAAK,EAAE,UAAU,IAAI,UAAU;AAC9C,SAAK,oBAAoB;AAEzB,QAAI,CAAC,KAAK,gBAAA,KAAqB,KAAK,gBAAgB,UAAU;AAC5D,WAAK,UAAU,SAAS;AAAA,IAC1B;AACA,QAAI,CAAC,KAAK,iBAAA,KAAsB,KAAK,gBAAgB,WAAW;AAC9D,WAAK,UAAU,SAAS;AAAA,IAC1B;AACA,QAAI,CAAC,KAAK,iBAAA,KAAsB,KAAK,gBAAgB,WAAW;AAC9D,WAAK,UAAU,QAAQ;AAAA,IACzB;AAEK,SAAA,UAAU,KAAK,WAAW;AAAA,EACjC;AAAA,EAEA,eAAe;AACR,SAAA,gBAAgB,UAAU,sBAC7B,GAAGF,QAAM,GAAGC,WAAS,KAAK,KAAK,aACjC;AACK,SAAA,eAAe,KAAK,cAAc;AACvC,SAAK,YAAY,iBAAiB,aAAa,KAAK,aAAa;AAAA,EACnE;AAAA;AAAA,EAGA,YAAY,OAAO,QAAQ,MAAM;AAC/B,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAEZ,UAAA,QAAQ,KAAK,UAAU,SAAS;AAEtC,SAAK,YAAY,MAAM;AAAA,MAAI,CAAC,GAAG,MAC7B;AAAA,QACE;AAAA,QACA;AAAA,UACE,SAAS;AAAA,YACP,WAAW,EAAE,QAAQ;AAAA,UACvB;AAAA,UACA,SAAS,6BAAM;AACb,iBAAK,WAAW,CAAC;AAAA,UACnB,GAFS;AAAA,QAGX;AAAA,QACA;AAAA,UACE,IAAI,kBAAkB;AAAA,UACtB;AAAA,YACE;AAAA,YACA;AAAA,cACE,aAAa,EAAE,SAAS,EAAE;AAAA,YAC5B;AAAA,YACA,EAAE,QACE,IAAI,QAAQ;AAAA,cACV,aAAa,EAAE;AAAA,YAChB,CAAA,IACD,CAAC;AAAA,UACP;AAAA,QACF;AAAA,MACF;AAAA,IAAA;AAGF,SAAK,eAAe,gBAAgB,GAAG,KAAK,SAAS;AAErD,QAAI,OAAO;AACT,WAAK,oBAAoB;AACzB,WAAK,WAAW,CAAC;AAAA,IAAA,OACZ;AACC,YAAA,QAAQ,KAAK,UAAU,YAAY;AAErC,UAAA,QAAQ,MAAM,UAAU,CAAC,SAAS,KAAK,UAAU,SAAS,UAAU,CAAC;AACrE,UAAA,UAAU,GAAI,SAAQ,KAAK;AAC1B,WAAA,WAAW,OAAO,IAAI;AAAA,IAC7B;AAEM,UAAA,UAAU,CAAC,GAAG,KAAK;AACzB,SAAK,WAAW;AAChB,SAAK,YAAY,IAAI,cAAc,KAAK,gBAAgB,IAAI;AAC5D,SAAK,UAAU;AAAA,MACb;AAAA;AAAA,MAEA,CAAC,EAAE,QAAQ,EAAE,aAAa,oBAAoB;AAC5C,YAAI,gBAAgB,YAAa;AACzB,gBAAA,OAAO,aAAa,GAAG,QAAQ,OAAO,aAAa,CAAC,EAAE,CAAC,CAAC;AAChE,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,eAAK,kBAAkB;AAAA,YACrB,WAAW,QAAQ,CAAC,EAAE;AAAA,YACtB,SAAS;AAAA,YACT,MAAM;AAAA,YACN,OAAO;AAAA,UAAA,CACR;AAAA,QACH;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,kBAAkB,OAKf;AACD,UAAM,EAAE,WAAW,SAAS,MAAM,UAAU;AAE5C,UAAM,WAAY,KAAK,cAAc,KAAK,aAAa,MAAM;AACvD,UAAA,WAAY,SAAS,UAAU;AACrC,UAAM,UAAW,SAAS,aAAa,KAAK,sBAAsB,MAAM;AACxE,UAAM,UAAW,QAAQ,OAAO,MAAM,CAAA;AAClC,QAAA,OAAO,UAAU,UAAU;AAC7B,YAAM,SAAU,QAAQ,IAAI,MAAM,CAAA;AAC3B,aAAA,OAAO,QAAQ,KAAK;AAAA,IAAA,OACtB;AACL,cAAQ,IAAI,IAAI;AAAA,IAClB;AAAA,EACF;AAAA;AAAA,EAGA,eAAe,SAAS,MAAM,OAAO,aAAa,SAAS,YAAY,MAAM;AACvE,QAAA,UAAU,YAAqB,SAAA;AAE7B,UAAA;AAAA;AAAA,MAEJ,KAAK,cAAc,KAAK,aAAa,GAAG,QACtC,KAAK,sBACP,IAAI,OAAO,IAAI,IAAI;AAAA;AACrB,QAAI,MAAM;AACJ,UAAA,KAAK,QAAQ,MAAM;AACrB,gBAAQ,KAAK;AAAA,MACf;AACI,UAAA,KAAK,WAAW,MAAM;AACxB,kBAAU,KAAK;AAAA,MACjB;AAAA,IACF;AAEA,WAAO,IAAI,OAAO;AAAA,MAChB,IAAI,SAAS;AAAA,QACX;AAAA,QACA;AAAA,QACA,MAAM;AAAA;AAAA,QAEN,UAAU,wBAAC,MAAM;AACf,eAAK,kBAAkB;AAAA,YACrB;AAAA,YACA;AAAA,YACA,OAAO,EAAE,MAAM,EAAE,OAAO,MAAM;AAAA,UAAA,CAC/B;AAAA,QACH,GANU;AAAA,MAMV,CACD;AAAA,MACD,IAAI,SAAS,EAAE,aAAa,aAAa;AAAA,QACvC,IAAI,SAAS;AAAA,UACX,MAAM;AAAA,UACN;AAAA,UACA,UAAU,CAAC;AAAA;AAAA,UAEX,UAAU,wBAAC,MAAM;AACf,iBAAK,kBAAkB;AAAA,cACrB;AAAA,cACA;AAAA,cACA,OAAO,EAAE,SAAS,CAAC,CAAC,EAAE,OAAO,QAAQ;AAAA,YAAA,CACtC;AAAA,UACH,GANU;AAAA,QAMV,CACD;AAAA,MAAA,CACF;AAAA,IAAA,CACF;AAAA,EACH;AAAA,EAEA,mBAAmB;AACjB,UAAM,UACJ,KAAK,UAAU,kBAAkB,KAAK,sBAAsB;AAC9D,UAAM,QAAQ,OAAO,KAAK,WAAW,CAAE,CAAA;AAEvC,UAAM,OAAO,IAAI,MAAM,MAAM,WAAW,KAAK,aAAa;AAC1D,UAAM,SAAS,KAAK,SAAS,KAAK,sBAAsB,GAAG;AAC3D,SAAK,YAAY;AAAA,MACf,GAAG,MAAM,IAAI,CAAC,YAAY;AACxB,eAAO,KAAK;AAAA,UACV;AAAA,UACA;AAAA,UACA,QAAQ,OAAO;AAAA,UACf;AAAA,UACA,SAAS,OAAO,GAAG,YAAY;AAAA,QAAA;AAAA,MACjC,CACD;AAAA,IAAA;AAEI,WAAA,CAAC,CAAC,MAAM;AAAA,EACjB;AAAA,EAEA,kBAAkB;AAChB,UAAM,SAAS,KAAK,UAAU,WAAW,KAAK,sBAAsB;AACpE,UAAM,QAAQ,OAAO,KAAK,UAAU,CAAE,CAAA;AAEtC,UAAM,OAAO,IAAI,MAAM,MAAM,WAAW,KAAK,aAAa;AAC1D,UAAM,SAAS,KAAK,SAAS,KAAK,sBAAsB,GAAG;AAC3D,SAAK,WAAW;AAAA,MAEd,GAAG,MACA,IAAI,CAAC,YAAY;AACZ,YAAA,QAAQ,OAAO,OAAO;AAC1B,YAAI,CAAC,OAAO;AACV;AAAA,QACF;AAEA,eAAO,KAAK;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,SAAS,OAAO,GAAG,YAAY;AAAA,QAAA;AAAA,MACjC,CACD,EACA,OAAO,OAAO;AAAA,IAAA;AAEZ,WAAA,CAAC,CAAC,MAAM;AAAA,EACjB;AAAA,EAEA,mBAAmB;AACX,UAAA,QAAQ,KAAK,UAAU,SAAS;AAChC,UAAA,eAAe,KAAK,UAAU;AAAA,MAClC,MAAM,KAAK,sBAAsB;AAAA,IAAA;AAE7B,UAAA,UAAU,cAAc,UAAU;AACxC,UAAM,eACJ,KAAK,UAAU,kBAAkB,KAAK,sBAAsB;AAG9D,UAAM,OAAO,IAAI,MAAM,MAAM,WAAW,KAAK,aAAa;AAC1D,UAAM,SAAS,KAAK,SAAS,KAAK,sBAAsB,GAAG;AAC3D,UAAM,OAAO,KAAK,UAAU,SAAS,MAAM,KAAK,sBAAsB;AAChE,UAAA,YAAY,KAAK,SAAS;AAChC,SAAK,YAAY;AAAA,MACf,GAAG,QAEA,IAAI,CAACE,OAAM,SAAS;AACb,cAAA,mBAAmB,eAAe,IAAI;AAC5C,cAAM,UAAU,aAAa,cAAc,IAAI,KAAKA;AAChD,YAAA,QAAQ,SAAS,IAAI,GAAG;AAC5B,cAAM,UAAU,SAAS,IAAI,GAAG,WAAW,oBAAoB;AAC3D,YAAA,CAAC,SAAS,UAAU,SAAS;AACvB,kBAAA;AAAA,QACV;AACA,eAAO,KAAK;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QAAA;AAAA,MACF,CACD,EACA,OAAO,OAAO;AAAA,IAAA;AAEZ,WAAA,CAAC,CAAC,QAAQ;AAAA,EACnB;AAAA;AAAA,EAGA,KAAK,MAAO;AACJ,UAAA,aAAa,OAAO,KAAK,IAAI,MAAM,OAAO,cAAc,CAAE,CAAA,EAAE;AAAA,MAChE,CAAC,GAAG,MAAM,EAAE,cAAc,CAAC;AAAA,IAAA;AAG7B,SAAK,iBAAiB;AAAA,MACpB;AAAA,IAAA;AAEG,SAAA,cAAc,IAAI,sCAAsC;AACxD,SAAA,aAAa,IAAI,sCAAsC;AACvD,SAAA,cAAc,IAAI,sCAAsC;AACvD,UAAA,QAAQ,IAAI,OAAO;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IAAA,CACN;AAED,SAAK,OAAO;AAAA,MACV,CAAC,UAAU,KAAK,UAAU;AAAA,MAC1B,CAAC,WAAW,KAAK,WAAW;AAAA,MAC5B,CAAC,WAAW,KAAK,WAAW;AAAA;AAAA,MAE5B,OAAO,CAAC,GAAG,CAAC,MAAM,IAAI,MAA6B;AAEnD,QAAE,IAAI,IAAI;AAAA,QACR,KAAK,IAAI,KAAK;AAAA,UACZ,SAAS,6BAAM;AACb,iBAAK,UAAU,IAAI;AAAA,UACrB,GAFS;AAAA,UAGT,aAAa;AAAA,QAAA,CACd;AAAA,QACD;AAAA,MAAA;AAEK,aAAA;AAAA,IACT,GAAG,CAAE,CAAA;AAEC,UAAA,QAAQ,IAAI,gCAAgC;AAAA,MAChD,IAAI,UAAU;AAAA,QACZ,IAAI,MAAM,aAAa;AAAA,QACvB;AAAA,UACE;AAAA,UACA;AAAA;AAAA,YAEE,UAAU,wBAAC,MAAM;AACV,mBAAA,YAAY,EAAE,OAAO,KAAK;AAAA,YACjC,GAFU;AAAA,UAGZ;AAAA,UACA,WAAW;AAAA,YAAI,CAAC,MACd,IAAI,UAAU;AAAA,cACZ,aAAa;AAAA,cACb,UAAU,GAAGH,QAAM,GAAGC,WAAS,GAAG,CAAC,OAAO;AAAA,cAC1C,OAAO;AAAA,YAAA,CACR;AAAA,UACH;AAAA,QACF;AAAA,MAAA,CACD;AAAA,MACD,IAAI,QAAQ;AAAA,QACV,IAAI,mCAAmC,KAAK,cAAc;AAAA,QAC1D,IAAI,mCAAmC;AAAA,UACrC;AAAA,YACE;AAAA,YACA,OAAO,OAAO,KAAK,IAAI,EAAE,IAAI,CAACG,OAAMA,GAAE,GAAG;AAAA,UAC3C;AAAA,UACA;AAAA,QAAA,CACD;AAAA,MAAA,CACF;AAAA,MACD,IAAI,UAAU;AAAA,QACZ;AAAA,UACE;AAAA,UACA;AAAA,YACE,SAAS,6BAAM;AACP,oBAAA,OAAO,IAAI,MAAM,MAAM;AAAA,gBAC3B,CAAC,MAAM,EAAE,SAAS,GAAGJ,QAAM,GAAGC,WAAS,KAAK,KAAK;AAAA,cAAA;AAEnD,kBAAI,MAAM;AACR,8BAAgB,EAAA;AAAA,kBACd;AAAA,gBAAA;AAEF;AAAA,cACF;AAEE,kBAAA;AAAA,gBACE,8CAA8C,KAAK,aAAa;AAAA,cAAA,GAElE;AAEA,uBAAO,IAAI,MAAM,MAAM,WAAW,KAAK,aAAa;AAC1C,0BAAA;AAAA,kBACR,GAAGD,QAAM,GAAGC,WAAS,KAAK,KAAK;AAAA,gBAAA;AAAA,cAEnC;AACA,mBAAK,KAAK;AAAA,YACZ,GAtBS;AAAA,UAuBX;AAAA,UACA;AAAA,QACF;AAAA,QACA;AAAA,UACE;AAAA,UACA;AAAA,YACE,SAAS,mCAAY;AACf,kBAAA;AACJ,kBAAI,gBAAgB,CAAA;AACpB,oBAAM,QAAQ,CAAA;AACH,yBAAA,KAAK,KAAK,eAAe;AAElC,sBAAME,QAAO,IAAI,MAAM,MAAM,WAAW,CAAC;AACrC,oBAAA,SAAUA,MAAK,WAAW;AAE9B,oBAAI,WAAW,KAAK,cAAc,CAAC,GAAG;AACtC,oBAAI,UAAU;AACN,wBAAA,OAAO,OAAO,KAAK,QAAQ;AAEjC,sBAAI,SAAS,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG;AAE5B,0BAAM,eAAe,CAAA;AACrB,0BAAM,cAAc,CAAA;AACpB,0BAAM,gBAAgB,CAAA;AAEtB,+BAAW,KAAK,MAAM;AAEpB,4BAAM,QAAQ,SAAS,CAAC,EAAE,KAAK,EAAE;AACjC,mCAAa,KAAK,IAAIA,MAAK,MAAM,CAAC,CAAC;AAEvB,kCAAA,KAAK,IAAI,SAAS,CAAC;AAClB,mCAAA,KAAK,EAAE,QAAQ;AAAA,oBAC9B;AAGW,+BAAA,KAAKA,MAAK,OAAO;AAC1B,0BAAI,EAAE,CAAC,KAAK,KAAQ,GAAA,CAAC,IAAIA,MAAK,MAAM,EAAE,CAAC,CAAC,EAAE;AAC1C,0BAAI,EAAE,CAAC,KAAK,KAAQ,GAAA,CAAC,IAAIA,MAAK,MAAM,EAAE,CAAC,CAAC,EAAE;AAAA,oBAC5C;AAGA,wBAAIA,MAAK,UAAU;AACN,iCAAAE,QAAOF,MAAK,UAAU;AAC/B,wBAAAE,KAAI,CAAC,IAAIF,MAAK,MAAME,KAAI,CAAC,CAAC;AAAA,sBAC5B;AAAA,oBACF;AAGA,+BAAWN,OAAM,MAAM;AACjB,0BAAA,OAAOA,GAAE,GAAG;AAEd,sCAAcI,MAAK,MAAMJ,GAAE,EAAE,KAAK,IAAI,OAAOA,GAAE;AAAA,sBACjD;AACA,6BAAO,OAAOA,GAAE;AAAA,oBAClB;AAEAI,0BAAK,QAAQ;AACF,+BAAA;AACXA,0BAAK,SAAS,SAAS;AAAA,kBACzB;AAEA,wBAAM,QAAQ,QAAQ;AAAA,gBACxB;AAGA,sBAAM,CAAC,IAAIA;AAEX,oBAAI,CAAC,aAAa;AAChB,gCAAc,IAAI,MAAM,MAAM,OAAO,CAAC,GAAG,MAAM;AAE3C,sBAAA,EAAE,IAAI,MAAM;AAEd,sBAAE,EAAE,IAAI,EAAE,KAAK,CAAC;AACT,2BAAA;AAAA,kBACT,GAAG,CAAE,CAAA;AAAA,gBACP;AAGA,sBAAM,QAAQ,YAAY,GAAGH,QAAM,GAAGC,WAAS,KAAK,CAAC;AACrD,oBAAI,MAAO,eAAc,KAAK,GAAG,KAAK;AAAA,cACxC;AAEA,oBAAM,gBAAgB,qBAAqB,OAAO,CAAE,CAAA;AAEpD,yBAAW,QAAQ,eAAe;AAChC,qBAAK,SAAS;AAAA,cAChB;AAEA,mBAAK,gBAAgB;AACrB,mBAAK,IAAI,MAAM,eAAe,MAAM,IAAI;AACnC,mBAAA,YAAY,KAAK,eAAe,KAAK;AAAA,YAC5C,GArFS;AAAA,UAsFX;AAAA,UACA;AAAA,QACF;AAAA,QACA;AAAA,UACE;AAAA,UACA,EAAE,SAAS,6BAAM,KAAK,QAAQ,SAAnB,WAA2B;AAAA,UACtC;AAAA,QACF;AAAA,MAAA,CACD;AAAA,IAAA,CACF;AAEI,SAAA,QAAQ,gBAAgB,KAAK;AAC7B,SAAA;AAAA,MACH,OACI,WAAW,KAAK,CAAC,MAAM,GAAGD,QAAM,GAAGC,WAAS,GAAG,CAAC,OAAO,IAAI,KACzD,WAAW,CAAC,IACd,WAAW,CAAC;AAAA,IAAA;AAElB,SAAK,QAAQ;AAER,SAAA,QAAQ,iBAAiB,SAAS,MAAM;AAC3C,WAAK,WAAW;AAChB,WAAK,QAAQ;IAAO,CACrB;AAAA,EACH;AACF;;;;ACjjBa,MAAA,MAAM,wBAAC,GAAW,MAAsB;AACnD,SAAO,MAAM,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC;AACnC,GAFmB;AAWN,MAAA,MAAM,wBAAC,GAAW,MAAsB;AACnD,SAAO,KAAK,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;AACnC,GAFmB;ACEnB,MAAM,kCAAkB,IAAY;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAED,MAAM,WAAW,wBAAC,YAAiC;AAC3C,QAAA,MAAM,QAAQ,OAAO;AACrB,QAAA,MAAM,QAAQ,OAAO;AACpB,SAAA,EAAE,KAAK;AAChB,GAJiB;AAMjB,MAAM,wBAAwB,wBAC5B,OACA,UACa;AACP,QAAA,OAAO,MAAM,CAAC;AACpB,QAAM,WAAW,MAAM,CAAC,KAAK,CAAA;AAC7B,QAAM,WAAW,MAAM,CAAC,KAAK,CAAA;AAEvB,QAAA,SAAS,SAAS,QAAQ;AAC1B,QAAA,SAAS,SAAS,QAAQ;AAGhC,MAAI,OAAO,MAAM,OAAO,OAAO,OAAO,MAAM,OAAO,KAAK;AAC/C,WAAA;AAAA,EACT;AAEM,QAAA,QAAQ,SAAS,QAAQ;AACzB,QAAA,QAAQ,SAAS,QAAQ;AAE/B,QAAM,gBAAgB;AAAA;AAAA,IAEpB,KAAK,KAAK,IAAI,OAAO,KAAK,OAAO,GAAG;AAAA,IACpC,KAAK,KAAK,IAAI,OAAO,KAAK,OAAO,GAAG;AAAA,IACpC,MAAM,IAAI,OAAO,KAAK;AAAA,EAAA;AAGjB,SAAA;AAAA,IACL,CAAC,MAAM,EAAE,GAAG,UAAU,GAAG,eAAe;AAAA,IACxC,CAAC,MAAM,EAAE,GAAG,UAAU,GAAG,eAAe;AAAA,EAAA;AAE5C,GA9B8B;AAgC9B,MAAM,sBAAsB,wBAC1B,OACA,UACa;AACb,QAAM,WAAW,MAAM,CAAC,KAAK,CAAA;AAC7B,QAAM,WAAW,MAAM,CAAC,KAAK,CAAA;AAEvB,QAAA,gBAAgB,yBAAyB,KAAK;AAC9C,QAAA,gBAAgB,yBAAyB,KAAK;AAEpD,QAAM,eAAe,EAAE,aAAa,eAAe,aAAa;AAG5D,MAAA,aAAa,WAAW,GAAG;AACtB,WAAA;AAAA,EACT;AAEO,SAAA;AAAA,IACL,CAAC,SAAS,EAAE,GAAG,UAAU,SAAS,cAAc;AAAA,IAChD,CAAC,SAAS,EAAE,GAAG,UAAU,SAAS,cAAc;AAAA,EAAA;AAEpD,GArB4B;AAuB5B,MAAM,uBAAuB,wBAC3B,OACA,UACa;AACP,QAAA,OAAO,iBAAiB,KAAK;AACnC,QAAM,WAAW,MAAM,CAAC,KAAK,CAAA;AAC7B,QAAM,WAAW,MAAM,CAAC,KAAK,CAAA;AAEvB,QAAA,cAAc,EAAE,MAAM,EAAE,KAAK,QAAQ,GAAG,EAAE,KAAK,QAAQ,CAAC,EAAE;AAAA,IAC9D,CAAC,QAAQ,CAAC,YAAY,IAAI,GAAG;AAAA,EAAA;AAG/B,QAAM,eAAe,YAAY,MAAM,CAAC,QAAQ;AACxC,UAAA,SAAS,SAAS,GAAG;AACrB,UAAA,SAAS,SAAS,GAAG;AACpB,WAAA,WAAW,UAAW,EAAE,MAAM,MAAM,KAAK,EAAE,MAAM,MAAM;AAAA,EAAA,CAC/D;AAEM,SAAA,eAAgB,CAAC,MAAM,EAAE,GAAG,UAAU,GAAG,SAAS,CAAC,IAAU;AACtE,GAnB6B;AA4BhB,MAAA,iBAAiB,wBAC5B,OACA,UACqB;AACf,QAAA,QAAQ,iBAAiB,KAAK;AAC9B,QAAA,QAAQ,iBAAiB,KAAK;AAEpC,MAAI,UAAU,OAAO;AACZ,WAAA;AAAA,EACT;AAEA,MAAI,eAAe,KAAK,KAAK,iBAAiB,KAAK,GAAG;AAC7C,WAAA,sBAAsB,OAAO,KAAqB;AAAA,EAC3D;AAEI,MAAA,iBAAiB,KAAK,GAAG;AACpB,WAAA,oBAAoB,OAAO,KAAqB;AAAA,EACzD;AAEO,SAAA,qBAAqB,OAAO,KAAK;AAC1C,GApB8B;AChG9B,MAAM,sBAAsB;AACrB,MAAM,sBAAsB,WAAW;AAAA,SAAA;AAAA;AAAA;AAAA,EAC5C;AAAA,EACA;AAAA,EACA,OAAgB;AAAA,EAChB,YAAY,OAAe;AACzB,UAAM,KAAK;AACN,SAAA,UAAU,2BAA2B,GAAG;AAC7C,SAAK,oBAAoB;AACzB,SAAK,gBAAgB;AAErB,QAAI,CAAC,KAAK,cAAc,EAAE,uBAAuB,KAAK,aAAa;AAC5D,WAAA,YAAY,qBAAqB,OAAO,SAAS;AAAA,IACxD;AAAA,EACF;AAAA,EAES,aAAa,aAAsB,IAAI;AAC9C,QAAI,CAAC,KAAK,QAAQ,CAAC,EAAE,OAAO,OAAQ;AAEpC,UAAM,QAAQ;AAAA,MACZ,GAAG,KAAK,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC,MAAM,IAAI,MAAM,MAAM,CAAC,CAAC;AAAA,MACtD,GAAG;AAAA,IAAA;AAEL,QAAI,IAAI,KAAK,UAAU,CAAC,EAAE;AAC1B,QAAI,KAAK,KAAK,WAAW,mBAAmB,GAAG;AAC7C,UAAI,sBAAsB,IAAI,MAAM,OAAO,CAAW;AAAA,IACxD;AAGA,eAAW,YAAY,OAAO;AAC5B,YAAM,OAAO,KAAK,OAAO,YAAY,SAAS,SAAS;AACvD,YAAM,QAAQ,MAAM,OAAO,SAAS,WAAW;AAC/C,UAAI,CAAC,OAAO;AACF,gBAAA,KAAK,4CAA4C,QAAQ;AACjE;AAAA,MACF;AAEM,YAAA,aAAa,MAAM,QAAQ;AACjC,UAAI,CAAC,YAAY;AACP,gBAAA,KAAK,iCAAiC,MAAM,MAAM;AAC1D;AAAA,MACF;AAEM,YAAA,SAAS,KAAK,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU;AAC9D,UAAI,CAAC,QAAQ;AACH,gBAAA;AAAA,UACN,0BAA0B,UAAU,cAAc,KAAK,EAAE;AAAA,QAAA;AAE3D;AAAA,MACF;AAEA,aAAO,QAAQ;AACR,aAAA;AAAA,QACL,OAAO;AAAA,QACP,IAAI;AAAA,QACJ;AAAA,QACA,IAAI,OAAO;AAAA,QACX,CAAC;AAAA,MAAA;AAAA,IAEL;AAAA,EACF;AAAA,EAES,qBAAqB;AACtB,UAAA,SAAS,KAAK,UAAU,CAAC;AAC3B,QAAA,QAAQ,SAAS,SAAS;AAErB,aAAA,QAAQ,SAAS,KAAK,QAAQ,CAAC,EAAE,OAAO,UAAU,EAAE,EAAE,CAAC;AAG9D,UAAI,CAAC,OAAO,QAAQ,OAAO,SAAS,OAAO,KAAe,GAAG;AAE3D,eAAO,QAAQ,OAAO,QAAQ,OAAO,CAAC;AACpC,eAAO,SAAsB,OAAO,KAAK;AAAA,MAC7C;AAAA,IACF;AAAA,EACF;AAAA,EAES,yBAAyB;AAC5B,QAAA,KAAK,QAAQ,CAAC,EAAE,OAAO,UAAU,CAAC,KAAK,SAAS,QAAQ;AAC1D,WAAK,mBAAmB;AAGpB,UAAA,KAAK,WAAW,KAAK,gBAAgB;AACvC,iBAAS,IAAI,GAAG,IAAI,KAAK,eAAe,QAAQ,KAAK;AAC7C,gBAAA,IAAI,KAAK,QAAQ,CAAC;AACxB,cAAI,GAAG;AACH,cAAA,QAAQ,KAAK,eAAe,CAAC;AAAA,UACjC;AAAA,QACF;AAAA,MACF;AAGA,WAAK,mBAAmB;AAAA,IAC1B;AAAA,EACF;AAAA,EAES,oBACP,OACA,QACA,WACA;AACA,QAAI,IAAI,kBAAkB;AAExB;AAAA,IACF;AAEA,UAAM,QAAQ,KAAK,QAAQ,CAAC,EAAE;AAC9B,QAAI,WAAW;AACb,UAAI,OAAO,UAAU,CAAC,KAAK,SAAS,QAAQ;AAC1C,aAAK,mBAAmB;AAAA,MAC1B;AAAA,IAAA,OACK;AAEL,WAAK,mBAAmB;AAEpB,UAAA,CAAC,OAAO,QAAQ;AAClB,aAAK,iBAAiB;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AAAA,EAES,gBACP,MACA,OACA,OACA,aACA,aACA;AAGA,QAAI,CAAC,MAAM,UAAU,EAAE,MAAM,QAAQ,eAAe;AAC3C,aAAA;AAAA,IACT;AAEA,QAAI,KAAK,QAAQ,IAAI,EAAE,OAAO,QAAQ;AAC9B,YAAA,QAAQ,KAAK,mBAAmB,KAAK;AAC3C,UAAI,OAAO;AAEJ,aAAA,aAAa,CAAC,EAAE,WAAW,YAAY,IAAI,YAAsB,CAAA,CAAC;AAAA,MACzE;AACO,aAAA;AAAA,IACT;AAEO,WAAA;AAAA,EACT;AAAA,EAEA,mBAAmB,YAAsB;AAEvC,QAAI,CAAC,KAAK,QAAQ,CAAC,EAAE,OAAO;AAC1B,WAAK,iBAAiB;AACtB;AAAA,IACF;AACA,UAAM,SAAS,KAAK,QAAQ,CAAC,EAAE,MAAM,CAAC;AAEtC,UAAM,OAAO,KAAK,MAAM,MAAM,MAAM;AACpC,QAAI,CAAC,KAAM;AAGX,UAAM,YAAY,KAAK,MAAM,YAAY,KAAK,SAAS;AACvD,QAAI,CAAC,aAAa,CAAC,UAAU,OAAQ;AAErC,UAAM,QAAQ,UAAU,OAAO,KAAK,WAAW;AAC/C,QAAI,CAAC,MAAO;AAER,QAAA;AACA,QAAA,CAAC,MAAM,QAAQ;AACb,UAAA,EAAE,MAAM,QAAQ,cAAe;AACnC,eAAS,EAAE,MAAM,MAAM,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,MAAM,CAAA,CAAE,EAAE;AAAA,IAAA,OAC7D;AACL,eAAS,MAAM;AAAA,IACjB;AAGM,UAAA,SAAS,OAAO,UAAU;AAChC,QAAI,CAAC,OAAQ;AAEb,UAAM,EAAE,KAAA,IAAS,cAAc,MAAM;AAEhC,SAAA,QAAQ,CAAC,EAAE,OAAO;AAClB,SAAA,QAAQ,CAAC,EAAE,OAAO;AAClB,SAAA,QAAQ,CAAC,EAAE,SAAS;AAEpB,SAAA;AAAA,MACH,OAAO,MAAM,KAAK;AAAA,MAClB;AAAA,MACA,OAAO;AAAA;AAAA,MAEP;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,cACE,WACA,MACA,YACA,YACA;AACI,QAAA,OAAO,UAAU,CAAC;AAEtB,QAAI,gBAAgB,OAAO;AAClB,aAAA;AAAA,IACT;AAGA,UAAM,CAAC,UAAU,SAAS,IAAI,KAAK;AAC/B,QAAA;AACJ,QAAI,QAAQ,cAAc;AACd,gBAAA,aAAa,IAAI,EAAE,MAAM,SAAS,WAAW,GAAG,KAAK,CAAI,GAAA;AAAA,IAAA,OAC9D;AAEL,eAAS,KAAK,UAAU,MAAM,SAAS,MAAM,MAAM;AAAA,MAAC,GAAG,CAAE,CAAA;AAAA,IAC3D;AAEI,QAAA,MAAM,WAAW,QAAQ;AACrB,YAAA,cAAc,KAAK,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU;AAClE,UAAI,aAAa;AACf,eAAO,QAAQ,YAAY;AAAA,MAC7B;AAAA,IACF;AAGE,QAAA,CAAC,YAAY,CAAC,GAAG,2BAChB,OAAO,SAAS,YAAY,OAAO,SAAS,UAC7C;AACI,UAAA,gBAAgB,KAAK,iBAAiB,CAAC;AAC3C,UAAI,CAAC,eAAe;AACF,wBAAA;AAAA,MAClB;AACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAEE,UAAA,SAAS,KAAK,iBAAiB,CAAC;AACpC,UAAI,UAAU,KAAK,WAAW,KAAK,QAAQ,WAAW,GAAG;AAClD,aAAA,QAAQ,CAAC,EAAE,QAAQ;AAAA,MAC1B;AAAA,IACF;AAGA,UAAM,gBAAgB,KAAK;AAC3B,QACE,KAAK,WACL,KAAK,aAAa,KAAK,QAAQ,CAAC,GAAG,QACnC,eAAe,WAAW,KAAK,QAAQ,SAAS,GAChD;AACA,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,aAAK,QAAQ,IAAI,CAAC,EAAE,QAAQ,cAAc,CAAC;AAAA,MAC7C;AAAA,IACF;AAIA,WAAO,WAAW,iBAAiB,OAAO,UAAU,MAAM;AACxD,WAAK,aAAa;AAAA,IAAA,CACnB;AAGD,SAAK,QAAQ;AAAA,MACX,KAAK,IAAI,KAAK,KAAK,CAAC,GAAG,QAAQ;AAAA,MAC/B,KAAK,IAAI,KAAK,KAAK,CAAC,GAAG,SAAS;AAAA,IAAA,CACjC;AAED,QAAI,CAAC,YAAY;AAET,YAAA,KAAK,KAAK;AAChB,UAAI,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG;AACxB,aAAK,KAAK,CAAC,IAAI,GAAG,CAAC;AAAA,MACrB;AACA,UAAI,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG;AACxB,aAAK,KAAK,CAAC,IAAI,GAAG,CAAC;AAAA,MACrB;AAEA,4BAAsB,MAAM;AACrB,aAAA,WAAW,KAAK,IAAI;AAAA,MAAA,CAC1B;AAAA,IACH;AAAA,EACF;AAAA,EAEA,iBAAiB;AACf,UAAM,SAAS,KAAK,SAAS,IAAI,CAAC,MAAM,EAAE,KAAK;AAC/C,SAAK,eAAe;AACpB,SAAK,mBAAmB,IAAI;AACxB,QAAA,QAAQ,UAAU,KAAK,SAAS;AAClC,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ;AACvC,aAAK,QAAQ,CAAC,EAAE,QAAQ,OAAO,CAAC;AAAA,IACpC;AACO,WAAA,KAAK,UAAU,CAAC;AAAA,EACzB;AAAA,EAEA,qBAAqB;AAEb,UAAA,SAAS,KAAK,QAAQ,CAAC;AACvB,UAAA,QAAQ,OAAO,SAAS;AAE9B,UAAM,YAAY,CAAC,CAAC,OAAO,SAAS,MAAM;AAC1C,QAAI,WAAW;AACN,aAAA,OAAO,SAAS,MAAM;AAAA,IAC/B;AAEI,QAAA,OAAO,SAAS,KAAK,WAAW;AAElC,UAAI,MAAM,QAAQ;AAChB,aAAK,eAAe;AAAA,MACtB;AAEA;AAAA,IACF;AACA,UAAM,UAAW,OAAO,SAAS,UAAU,IAAwB;AACnE,QAAI,CAAC,QAAS;AACd,UAAM,WAAW,QAAQ,CAAC,MAAM,SAAS,QAAQ,CAAC,MAAM;AACxD,QAAI,CAAC,SAAU;AAEf,eAAW,UAAU,OAAO;AAC1B,YAAM,OAAO,IAAI,MAAM,MAAM,MAAM;AACnC,UAAI,CAAC,KAAM;AAEX,YAAM,YAAY,IAAI,MAAM,YAAY,KAAK,SAAS;AACtD,UAAI,CAAC,UAAW;AAChB,YAAM,aAAa,UAAU,OAAO,KAAK,WAAW;AAG/C,WAAA,mBAAmB,YAAY,SAAS;AAAA,IAC/C;AAAA,EACF;AAAA,EAEA,mBAAmB,OAAuB,aAAuB;AAEzD,UAAA,SAAS,KAAK,UAAU,CAAC;AAC/B,UAAM,UAAW,MAAM,SAAS,UAAU,IAAwB;AAC9D,QAAA,CAAC,QAAgB,QAAA;AAEd,WAAA,CAAC,CAAC,aAAa;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK;AAAA,IAAA;AAAA,EAET;AAAA,EAEA,iBAAiB;AACf,QAAI,KAAK,SAAS;AAEL,iBAAA,KAAK,KAAK,SAAS;AAC5B,YAAI,EAAE,UAAU;AACd,YAAE,SAAS;AAAA,QACb;AAAA,MACF;AAIA,WAAK,gBAAgB;AACrB,WAAK,WAAW,KAAK,QAAQ,CAAC,GAAG;AACjC,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KAAK;AAC5C,aAAK,cAAc,KAAK,KAAK,QAAQ,CAAC,EAAE,KAAK;AAAA,MAC/C;AACA,iBAAW,MAAM;AACf,eAAO,KAAK;AACZ,eAAO,KAAK;AAAA,SACX,EAAE;AACL,WAAK,QAAQ,SAAS;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,mBAAmB;AAGZ,SAAA,QAAQ,CAAC,EAAE,OAAO;AAClB,SAAA,QAAQ,CAAC,EAAE,OAAO;AAChB,WAAA,KAAK,QAAQ,CAAC,EAAE;AAEvB,SAAK,eAAe;AAAA,EACtB;AACF;AAEO,SAAS,gBACd,MACW;AACH,SAAA,KAAK,SAAS,MAAM,KACzB,KAAK,SAAS,UAAU,SAA6B;AAAA,IACpD;AAAA,IACA,CAAC;AAAA,EAAA;AAEP;AARgB;AAUhB,SAAS,UAA4B,YAAoB;AACjD,QAAA,EAAE,SAAS,IAAI,KAAK;AAExB,SAAA,UAAU,OAAO,WAAW,UAAU,KACtC,UAAU,OAAO,WAAW,UAAU;AAE1C;AANS;AAeO,SAAA,eACd,MACA,QAC4B;AACpB,UAAA;AAAA,IACN;AAAA,EAAA;AAEK,SAAA,KAAK,OAAO,KAAK,CAAC,SAAS,KAAK,QAAQ,SAAS,OAAO,IAAI;AACrE;AARgB;AAUhB,SAAS,cAAc,QAAmB;AAEpC,MAAA,OAAO,OAAO,CAAC;AACnB,MAAI,gBAAgB,OAAO;AAClB,WAAA;AAAA,EACT;AACA,SAAO,EAAE,KAAK;AAChB;AAPS;AASO,SAAA,gBACd,MACA,QACA;AACI,MAAA,CAAC,KAAK,OAAQ;AAClB,MAAI,QAAQ;AACL,SAAA,OAAO,UAAU,IAAI,MAAM;AAAA,EAAA,OAC3B;AACL,WAAO,KAAK;AAAA,EACd;AAEA,MAAI,UAAU,MAAM;AAClB,UAAM,OAAO,IAAI,MAAM,MAAM,KAAK,QAAQ,EAAE;AAC5C,QAAI,MAAM;AACR,YAAM,aAAa,IAAI,MAAM,YAAY,KAAK,SAAS;AACnD,UAAA,cAAc,gBAAgB,UAAU,GAAG;AAC7C,YAAI,QAAQ;AACV,qBAAW,eAAe;AAAA,QAAA,WACjB,CAAC,IAAI,kBAAkB;AAChC,qBAAW,iBAAiB,CAAC;AAC7B,qBAAW,iBAAiB;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAzBgB;AA2BT,SAAS,aACd,QACA,SACA,aACA,gBACA,SACgC;AAChC,MAAI,CAAC,SAAS;AACZ,cAAU,gBAAgB,MAAM;AAAA,EAClC;AAEM,QAAA,aAAa,eAAe,SAAS,OAAO;AAElD,MAAI,cAAc,aAAa;AAC7B,QAAI,YAAY;AAEP,aAAA,OAAO,MAAM,IAAI;AAAA,IAC1B;AAGM,UAAA,SAAS,gBAAgB,KAAK,IAAI;AAExC,QAAI,QAAQ;AAEJ,YAAA,MAAM,OAAO,QAAQ;AAErB,YAAA,MAAM,OAAO,QAAQ;AAE3B,UAAI,OAAO,QAAQ,OAAO,QAAQ,YAAY,QAAQ;AAEtD,UAAI,OAAO,QAAQ,OAAO,QAAQ,YAAY,QAAQ;AAE/C,aAAA,SAAS,OAAO,KAAK;AAAA,IAC9B;AAAA,EACF;AAEA,SAAO,EAAE,cAAc,aAAa,CAAC,KAAK,CAAG,EAAA;AAC/C;AArCgB;AAuChB,IAAI,kBAAkB;AAAA,EACpB,MAAM;AAAA,EACN,MAAM,sBAAsB,UAAU,WAAWC,MAAK;AAE3C,aAAA,UAAU,uBAAuB,WAA4B;AAC5D,cAAA;AAAA,QACN;AAAA,MAAA;AAEK,aAAA;AAAA,IAAA;AAGT,aAAS,UAAU,oBAAoB;AAAA,MACrC,SAAS,UAAU;AAAA,MACnB,WAA4B;AACtB,YAAA,CAAC,KAAK,OAAQ;AAClB,aAAK,YAAY;AAEN,mBAAA,SAAS,KAAK,QAAQ;AAC/B,cAAI,MAAM,QAAQ;AACV,kBAAA,OAAO,MAAM,OAAO;AAC1B,gBAAI,CAAC,MAAM,OAAO,UAAU,GAAG;AAC7B,oBAAM,OAAO,UAAU,IAAI,MAAM,UAAU,KAAK,MAAM,IAAI;AAAA,YAC5D;AAEM,kBAAA,IAAI,KAAK,SAAS,KAAK,CAACI,OAAMA,GAAE,SAAS,IAAI;AACnD,gBAAI,CAAC,GAAG;AACD,mBAAA,YAAY,KAAK,OAAO,UAAU,CAAC,MAAM,MAAM,KAAK,CAAC;AAAA,YAC5D;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IAAA;AAGF,aAAS,UAAU,cAAc;AAAA,MAC/B,SAAS,UAAU;AAAA,MACnB,WAA4B;AAC1B,YAAI,CAACJ,KAAI,oBAAoB,KAAK,QAAQ;AAE7B,qBAAA,SAAS,KAAK,QAAQ;AAC/B,gBAAI,MAAM,UAAU,CAAC,MAAM,OAAO,UAAU,GAAG;AACvC,oBAAA,OAAO,MAAM,OAAO;AAC1B,oBAAM,OAAO,UAAU,IAAI,MAAM,UAAU,KAAK,MAAM,IAAI;AAAA,YAC5D;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IAAA;AAGF,aAAS,YAAY,KAAc;AACtB,iBAAA,KAAKA,KAAI,MAAM,OAAO;AAC/B,YAAI,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG;AACvC,iBAAA;AAAA,QACT;AAAA,MACF;AACO,aAAA;AAAA,IACT;AAPS;AAUH,UAAA,sBAAsB,SAAS,UAAU;AAC/C,aAAS,UAAU,kBAAkB,YAEhC,CAAC,MAAM,GAAG,IAAI,GACjB;AACM,YAAA,IAAI,qBAAqB,MAAM,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC;AAEpD,YAAA,QAAQ,KAAK,OAAO,IAAI;AAC1B,UAAA,CAAC,MAAM,QAAQ;AAEjB,YACE,EAAE,MAAM,QAAQ,iBAChB,EAEI,MAAM,SAAS,UAAU,IACvB,IAAI,CAAC,aAAa,QAExB;AACO,iBAAA;AAAA,QACT;AAAA,MACF;AAGM,YAAA,OAAO,UAAU,WAAW,eAAe;AAC7C,UAAA,CAAC,KAAa,QAAA;AAElBA,WAAI,MAAM,IAAI,IAAI;AAGlB,YAAM,MAAwB;AAAA,QAC5B,KAAK,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI;AAAA,QAC7B,KAAK,IAAI,CAAC;AAAA,MAAA;AAEL,aAAA,YAAY,GAAG,GAAG;AACnB,YAAA,CAAC,KAAK,UAAU;AAAA,MACtB;AAEA,WAAK,MAAM;AACN,WAAA,QAAQ,GAAG,MAAM,IAAI;AAC1B,WAAK,QAAQ,MAAM;AAEZ,aAAA;AAAA,IAAA;AAAA,EAEX;AAAA,EACA,sBAAsB;AACV,cAAA;AAAA,MACR;AAAA,MACA,OAAO,OAAO,eAAe;AAAA,QAC3B,OAAO;AAAA,MAAA,CACR;AAAA,IAAA;AAEH,kBAAc,WAAW;AAAA,EAC3B;AACF,CAAC;;;;;;;;ACxkBD,MAAM,SAAS;AACf,MAAM,YAAY;AAElB,MAAM,WAAW;AAAA,EACf,OAAO;AAAA,IACL,MAAM;AAAA,IACN,YAAY;AAAA,IACZ,YAAY;AAAA,EACd;AAAA;AAAA,EAEA,iBAAiB,MAAM;AACrB,UAAMH,MAAK,GAAG,MAAM,GAAG,SAAS,GAAG,IAAI;AAGvC,QAAI,IAAI,MAAM,OAAO,aAAa,IAAI,GAAG;AACnC,UAAA,IAAI,MAAM,MAAM,KAAK,CAAC,MAAM,EAAE,SAASA,GAAE,GAAG;AAC9C,eAAO,SAAS,MAAM;AAAA,MAAA,OACjB;AACL,eAAO,SAAS,MAAM;AAAA,MACxB;AAAA,IACF;AACA,WAAO,SAAS,MAAM;AAAA,EACxB;AAAA,EACA,eAAe,MAAc,MAA6B;AACpD,QAAA,QAAQ,IAAI,MAAM;AACtB,QAAI,CAAC,MAAO,KAAI,MAAM,QAAQ,QAAQ;AACtC,QAAI,aAAa,MAAM;AACvB,QAAI,CAAC,WAAkB,OAAA,aAAa,aAAa,CAAA;AAEjD,eAAW,IAAI,IAAI;AAAA,EACrB;AACF;AAEA,MAAM,iBAAiB;AAAA,SAAA;AAAA;AAAA;AAAA,EACrB;AAAA;AAAA,EAEA;AAAA,EAEA,YAAY,OAAqB;AAC/B,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,MAAM,QAAQ;AACN,UAAA,OAAO,MAAM,KAAK;AACxB,QAAI,CAAC,KAAM;AAIX,SAAK,UAAU;AAEV,SAAA,WAAW,KAAK;AACZ,aAAA,eAAe,MAAM,KAAK,QAAQ;AAE3C,WAAO,EAAE,MAAM,UAAU,KAAK,SAAS;AAAA,EACzC;AAAA,EAEA,MAAM,UAAU;AACd,UAAM,OAAO,MAAM,iBAAiB,EAAE,OAAO;AAAA,MAC3C,OAAO,EAAE,kBAAkB;AAAA,MAC3B,SAAS,EAAE,qBAAqB;AAAA,MAChC,cAAc;AAAA,IAAA,CACf;AACD,QAAI,CAAC,KAAM;AACL,UAAA,OAAO,SAAS,iBAAiB,IAAI;AAC3C,YAAQ,MAAM;AAAA,MACZ,KAAK,SAAS,MAAM;AAClB,sBAAgB,EAAA;AAAA,UACd;AAAA,QAAA;AAEF;AAAA,MACF,KAAK,SAAS,MAAM;AAClB,YACE,CAAC;AAAA,UACC;AAAA,QAAA,GAEF;AACA;AAAA,QACF;AACA;AAAA,IACJ;AACO,WAAA;AAAA,EACT;AAAA,EAEA,YAAY;AAEV,UAAM,eAAe,IAAI,MAAM,sBAAsB,KAAK;AAC1D,SAAK,QAAQ,KAAK,MACf,IAAI,CAAC,UAAU,EAAE,OAAO,aAAa,QAAQ,IAAI,GAAG,KAAK,EAAE,EAE3D,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,KAAK,KAAK,EAAE,KAAK,EAAE,EACzD,IAAI,CAAC,EAAE,KAAA,MAAW,IAAI;AAAA,EAC3B;AAAA,EAEA,cAAc;AAEN,UAAA,iBAAiB,wBAAC,WAAW;AAEtB,iBAAA,QAAQ,OAAO,OAAO;AAC/B,cAAM,SAAS,IAAI,MAAM,YAAY,KAAK,CAAC,CAAC;AAE5C,cAAM,OAAO,OAAO,QAAQ,KAAK,CAAC,CAAC,EAAE;AACrC,aAAK,KAAK,IAAI;AAAA,MAChB;AAAA,IAAA,GAPqB;AAWjB,UAAA,qBAAqB,wBAAC,WAAW;AAErC,aAAO,WAAW;AAClB,eAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AACpC,cAAA,OAAO,KAAK,MAAM,CAAC;AACrB,YAAA,CAAC,KAAK,SAAS,OAAQ;AAC3B,iBAAS,OAAO,GAAG,OAAO,KAAK,QAAQ,QAAQ,QAAQ;AACrD,cAAI,cAAc;AACZ,gBAAA,SAAS,KAAK,QAAQ,IAAI;AAChC,cAAI,OAAO,OAAO;AACd,cAAA,CAAC,OAAO,OAAO,OAAQ;AAChB,qBAAA,KAAK,OAAO,OAAO;AAC5B,kBAAM,OAAO,IAAI,MAAM,MAAM,CAAC;AAC9B,gBAAI,CAAC,KAAM;AACP,gBAAA,SAAS,IAAK,QAAO,KAAK;AAE9B,gBAAI,CAAC,IAAI,OAAO,eAAe,KAAK,SAAS,GAAG;AAChC,4BAAA;AACd;AAAA,YACF;AAAA,UACF;AACA,cAAI,aAAa;AACf,mBAAO,SAAS,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAAA,UACtC;AAAA,QACF;AAAA,MACF;AAAA,IAAA,GAzByB;AA6BvB,QAAA;AAEF,YAAM,aAAa,UAAU,KAAK,OAAO,IAAI,OAAO,KAAK;AACnD,YAAA,SAAS,KAAK,MAAM,UAAU;AAEpC,qBAAe,MAAM;AACrB,yBAAmB,MAAM;AAElB,aAAA;AAAA,IAAA,UACP;AAAA,IACF;AAAA,EACF;AACF;AAEO,MAAM,gBAAgB;AAAA,SAAA;AAAA;AAAA;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAGA,YAAY,MAAM,UAAU;AAC1B,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,SAAS;AAEd,SAAK,aAAa;AAClB,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AACzB,SAAK,mBAAmB;AACxB,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AACzB,SAAK,gBAAgB;AACrB,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AACzB,SAAK,aAAa;AAClB,SAAK,mBAAmB;EAC1B;AAAA,EAEA,MAAM,aAAa,SAAS,QAAQ;AAClC,SAAK,UAAU;AAAA,MACb,QAAQ,CAAC;AAAA,MACT,aAAa,CAAC;AAAA,MACd,gBAAgB,CAAC;AAAA;AAAA,MAEjB,kBAAkB,CAAC;AAAA,MACnB,MAAM,SAAS,YAAY,KAAK;AAAA,MAChC,cAAc,KAAK;AAAA,MACnB,UAAU,iBAAiB,YAAY;AAAA,MACvC,OAAO,EAAE,UAAU,GAAG;AAAA,MACtB,aAAa,wBAAwB,KAAK,SAAS,MAEhD,IAAI,CAAC,MAAM,EAAE,IAAI,EACjB,KAAK,IAAI,CAAC;AAAA,MACb,eAAe,kBAAkB,KAAK;AAAA,MAEtC,CAAC,KAAK,GAAG;AAAA,IAAA;AAGX,SAAK,SAAS;AACd,UAAM,aAAa,CAAA;AACnB,UAAM,cAAc,CAAA;AACpB,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,MAAM,QAAQ,KAAK;AACnD,YAAM,OAAO,KAAK,SAAS,MAAM,CAAC;AAClC,WAAK,QAAQ;AACR,WAAA,YAAY,MAAM,YAAY,WAAW;AAAA,IAChD;AAEW,eAAA,KAAK,KAAK,qBAAqB;AAEtC;IACJ;AAEA,SAAK,sBAAsB;AACrB,UAAA,IAAI,gBAAgB,GAAG,MAAM,GAAG,SAAS,KAAK,KAAK,MAAM,KAAK,OAAO;AAC3D,sBAAE,WAAW,KAAK,OAAO;AAAA,EAC3C;AAAA,EAEA,WAAW;AACT,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,SAAK,eAAe;AAGT,eAAA,KAAK,KAAK,SAAS,OAAO;AACnC,YAAM,CAAC,cAAc,gBAAgB,cAAc,cAAc,IAAI;AAGrE,UAAI,gBAAgB,KAAM;AAG1B,UAAI,CAAC,KAAK,UAAU,YAAY,GAAG;AAE5B,aAAA,UAAU,YAAY,IAAI;MACjC;AAEA,UAAI,CAAC,KAAK,UAAU,YAAY,EAAE,cAAc,GAAG;AAEjD,aAAK,UAAU,YAAY,EAAE,cAAc,IAAI,CAAA;AAAA,MACjD;AAEA,WAAK,UAAU,YAAY,EAAE,cAAc,EAAE,KAAK,CAAC;AAGnD,UAAI,CAAC,KAAK,QAAQ,YAAY,GAAG;AAE1B,aAAA,QAAQ,YAAY,IAAI;MAC/B;AAEA,WAAK,QAAQ,YAAY,EAAE,cAAc,IAAI;AAAA,IAC/C;AAEI,QAAA,KAAK,SAAS,UAAU;AACfM,iBAAAA,QAAO,KAAK,SAAS,UAAU;AAExC,YAAI,CAAC,KAAK,aAAaA,KAAI,CAAC,CAAC,GAAG;AAE9B,eAAK,aAAaA,KAAI,CAAC,CAAC,IAAI,EAAE,CAACA,KAAI,CAAC,CAAC,GAAGA,KAAI,CAAC,EAAE;AAAA,QAAA,OAC1C;AAEA,eAAA,aAAaA,KAAI,CAAC,CAAC,EAAEA,KAAI,CAAC,CAAC,IAAIA,KAAI,CAAC;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,YAAY,MAAM,YAAY,aAAa;AACnC,UAAA,MAAM,KAAK,WAAW,IAAI;AAChC,QAAI,CAAC,IAAK;AAEJ,UAAA,SAAS,EAAE,GAAG,IAAI,OAAO,UAAU,GAAG,IAAI,OAAO;AAEvD,SAAK,OAAO,KAAK,KAAK,kBAAkB,MAAM,YAAY,MAAM,CAAC;AACjE,QAAI,IAAI,QAAQ,aAAa,mBAAmB,MAAM,aAAa,GAAG;AAAA,EACxE;AAAA;AAAA,EAGA,WAAW,MAAM;AAET,UAAA,MAAM,WAAW,KAAK,IAAI;AAChC,QAAI,IAAY,QAAA;AAGhB,UAAM,YAAY,KAAK,UAAU,KAAK,KAAK;AACvC,QAAA,KAAK,SAAS,iBAAiB;AAEjC,UAAI,CAAC,UAAW;AAEhB,UAAI,OAAO,UAAU,GAAG,EAAE,CAAC,EAAE,CAAC;AAC9B,UAAI,SAAS,SAAS;AAEpB,cAAM,SAAS,KAAK,QAAQ,CAAC,EAAE,OAAO;AAChC,cAAA,eAAe,KAAK,SAAS,MAAM,UAAU,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AAEzD,cAAA,WAAW,WAAW,YAAY;AAClC,cAAA,QACJ,SAAS,MAAM,SAAS,MAAM,KAAK,SAAS,MAAM,SAAS,MAAM;AACnE,eAAO,MAAM,CAAC;AAAA,MAChB;AAGA,YAAME,OAAO,KAAK,cAAc,KAAK,KAAK,IAAI;AAAA,QAC5C,OAAO;AAAA,UACL,UAAU;AAAA,YACR,OAAO,CAAC,MAAM,EAAE;AAAA,UAClB;AAAA,QACF;AAAA,QACA,QAAQ,CAAC,IAAI;AAAA,QACb,aAAa,CAAC;AAAA,QACd,gBAAgB,CAAC;AAAA,MAAA;AAEZA,aAAAA;AAAAA,IAAA,WACE,KAAK,SAAS,WAAW;AAElC,YAAM,UAAU,KAAK,QAAQ,KAAK,KAAK;AAEnC,UAAA,WAAW,aAAa,CAAC,KAAK,aAAa,KAAK,KAAK,IAAI,CAAC,GAAG;AAExD,eAAA;AAAA,MACT;AAEA,UAAI,SAAS,CAAA;AACb,UAAI,cAAc;AAClB,UAAI,WAAW;AACF,mBAAA,CAAKR,EAAAA,EAAAA,KAAI,IAAI,KAAK,UAAU,GAAG,GAAG;AAC3C,gBAAMS,QAAO,KAAK,SAAS,MAAMT,GAAE;AAC7B,gBAAA,QAAQS,MAAK,OAAO,IAAI;AAC9B,cAAI,gBAAgB,KAAK;AACvB,0BAAc,MAAM;AAAA,UACtB;AACA,cAAI,MAAM,QAAQ;AAEV,kBAAA,YAAY,WAAWA,MAAK,IAAI;AACtC,kBAAM,eACJ,UAAU,MAAM,SAAS,MAAM,OAAO,IAAI,KAC1C,UAAU,MAAM,SAAS,MAAM,OAAO,IAAI;AAE5C,kBAAM,SAAS,CAAC,aAAa,CAAC,GAAG,MAAM;AACvC,kBAAM,MAAM;AAAA,cACV;AAAA;AAAA,gBAEE;AAAA,cACF;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YAAA;AAEF,qBAAS,KAAK,gBAAgB;AAAA,UAChC;AAAA,QACF;AAAA,iBACS,SAAS;AAClB,cAAM,CAACT,KAAI,IAAI,IAAI,QAAQ,GAAG;AAC9B,sBAAc,KAAK,SAAS,MAAMA,GAAE,EAAE,QAAQ,IAAI,EAAE;AAAA,MAAA,OAC/C;AAEM,mBAAA,KAAK,KAAK,SAAS,OAAO;AACnC,cAAI,EAAE,CAAC,MAAM,KAAK,OAAO;AACvB,0BAAc,EAAE,CAAC;AACjB;AAAA,UACF;AAAA,QACF;AACA,YAAI,gBAAgB,KAAK;AAGvB,gBAAMK,KAAI,KAAK,aAAa,KAAK,KAAK,IAAI,CAAC;AAC3C,cAAIA,IAAG;AACSA,0BAAAA;AAAAA,UAChB;AAAA,QACF;AAAA,MACF;AAGA,aAAO,aAAa;AACb,aAAA;AAAA,QACL,OAAO;AAAA,UACL,UAAU;AAAA,YACR,CAAC,WAAW,GAAG,CAAC,aAAa,MAAM;AAAA,UACrC;AAAA,QACF;AAAA,QACA,QAAQ,CAAC,WAAW;AAAA,QACpB,aAAa,CAAC;AAAA,QACd,gBAAgB,CAAC;AAAA,MAAA;AAAA,IAErB;AAEQ,YAAA;AAAA,MACN,2BACE,KAAK,OACL,+BACA,KAAK;AAAA,IAAA;AAAA,EAEX;AAAA;AAAA,EAGA,eAAe,MAAM,WAAW,YAAY,QAAQ,OAAQ;AACpD,UAAA,eAAe,KAAK,SAAS,SAAS,KAAK,KAAK,GAAG,QAAQ,SAAS;AAC1E,QAAI,OACF,cAAc;AAAA,IAEd,KAAK,QAAQ,KAAK,CAAC,QAAQ,IAAI,SAAS,SAAS,GAAG,SACpD;AACF,QAAI,MAAM;AACV,QAAI,SAAS;AAEb,QAAK,KAAK,SAAS,mBAAmB,KAAK,SAAU,QAAQ,YAAY;AACvE,eAAS,GAAG,KAAK,SAAS,KAAK,IAAI;AACnC,YAAM,OAAO,GAAG,MAAM,GAAG,SAAS;AAClC,UAAI,QAAQ,YAAY;AACtB,eAAO,GAAG,MAAM,GAAG,WAAW,IAAI,CAAC,IAAI,SAAS;AAAA,MAClD;AAAA,IACF;AACA,eAAW,GAAG,KAAK,WAAW,GAAG,KAAK,KAAK;AAEvC,QAAA,cAAc,UAAU,cAAc,cAAc;AAClD,UAAA,CAAC,MAAO,SAAQ;AACd,YAAA,yBAAyB,GAAG,MAAM;AAAA,IAC1C;AACI,QAAA,OAAO,CAAC,MAAM,eAAe;AAC3B,UAAA,CAAC,MAAO,SAAQ;AACd,YAAA;AAAA,MAEJ,KAAK,kBAAkB,KAAK,KAAK,IAAI,OAAO,CAAC,GAAG,UAAU,OAAO,KACjE;AAAA,IACJ;AAEA,QAAI,OAAO;AACA,eAAA,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC,GAAG,GAAG,MAAA,CAAO;AAAA,IACjD;AAEO,WAAA,EAAE,MAAM,QAAQ;EACzB;AAAA;AAAA,EAGA,oBAAoB,QAAQ,MAAM,YAAY,YAAY;AACxD,UAAM,QAAQ,CAAA;AACR,UAAA,gCAAgB;AAEtB,UAAM,YAAa,KAAK,kBAAkB,KAAK,KAAK,IAAI;AACxD,eAAW,aAAa,YAAY;AAClC,UAAI,iBAAiB,cAAc,OAAO,SAAS,CAAC,GAAG;AAC/C,cAAA,iBAAiB,KAAK,QAAQ;AAAA;AAAA,UAElC,CAAC,QAAQ,IAAI,SAAS,aAAa,IAAI,QAAQ,SAAS;AAAA,QAAA;AAE1D,YAAI,iBAAiB,IAAI;AAGb,oBAAA,IAAI,gBAAgB,SAAS;AAEvC,oBAAU,SAAS,IAAI;AAAA,QAAA,OAClB;AAEL,gBAAM,EAAE,MAAM,OAAO,IAAI,KAAK;AAAA,YAC5B;AAAA,YACA;AAAA,YACA;AAAA,YACA,OAAO,SAAS;AAAA,UAAA;AAGlB,eAAK,QAAQ,MAAM,SAAS,IAAI,IAAI;AAEpC,oBAAU,SAAS,IAAI;AAEvB,eAAK,kBAAkB,IAAI,IAAI,EAAE,MAAM,UAAU;AAAA,QACnD;AAAA,MAAA,OACK;AAEL,cAAM,KAAK,SAAS;AAAA,MACtB;AAAA,IACF;AACO,WAAA,EAAE,WAAW;EACtB;AAAA;AAAA,EAGA,yBAAyB,MAAM,WAAW,QAAQ;AAChD,UAAM,aAAa,KAAK,SAAS,MAAM,KAAK,CAAC,CAAC;AAC1C,QAAA,WAAW,SAAS,iBAAiB;AAEvC,YAAM,CAAC,cAAcK,IAAG,cAAc,EAAE,IAAI;AAEtC,YAAA,eAAe,KAAK,cAAc,YAAY;AAC9C,YAAA,eAAe,OAAO,SAAS;AAC/B,YAAA,kBAAkB,aAAa,MAAM,SAAS;AAC9C,YAAA,SAAS,EAAE,QAAQ;AACzB,YAAM,SAAS;AAAA;AAAA,QAEb;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAEF,sBAAgB,CAAC,IACf,QAAQ,gBAAgB,OAAO,SAAS,EAAE,CAAC,IACvC,EAAE,GAAG,OAAO,SAAS,EAAE,CAAC,MACxB;AAGN,UAAI,OAAO,KAAK,kBAAkB,YAAY,EAAE,OAAO;AACvD,aAAO,KAAK,OAAO,GAAG,KAAK,SAAS,CAAC;AACrB,sBAAA,CAAC,EAAE,yBAAyB;AAC5B,sBAAA,CAAC,EAAE,iBAAiB;AAGhC,UAAA,cAAc,KAAK,kBAAkB,YAAY;AACrD,UAAI,CAAC,aAAa;AAEhB,sBAAc,KAAK,kBAAkB,YAAY,IAAI,CAAA;AAAA,MACvD;AACI,UAAA,YAAY,SAAS,GAAG;AACd,oBAAA,SAAS,EAAE,KAAK,YAAY;AAAA,MAC1C;AACA,kBAAY,SAAS,IAAI;AAGrB,UAAA,WAAW,KAAK,kBAAkB,YAAY;AAClD,UAAI,CAAC,UAAU;AAEb,mBAAW,KAAK,kBAAkB,YAAY,IAAI,CAAA;AAAA,MACpD;AACA,eAAS,KAAK,EAAE,QAAQ,cAAc,UAAW,CAAA;AAAA,IACnD;AAAA,EACF;AAAA;AAAA,EAGA,kBAAkB,QAAQ,MAAM,OAAO,SAAS,UAAU,YAAY;AAEpE,SAAK,WAAW,KAAK,KAAK,IAAI,CAAA;AAC9B,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAC/B,YAAA,YAAY,MAAM,CAAC;AACrB,UAAA,QAAQ,CAAC,GAAG;AACd,aAAK,yBAAyB,QAAQ,CAAC,GAAG,WAAW,MAAM;AAE3D;AAAA,MACF;AAEA,YAAM,EAAE,MAAM,QAAQ,iBAAiB,KAAK;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAO,SAAS;AAAA,MAAA;AAIlB,WAAK,WAAW,KAAK,KAAK,EAAE,SAAS,IAAI;AACrC,UAAA,cAAc,YAAY,MAAO;AAGrC,WAAK,QAAQ,MAAM,SAAS,IAAI,IAAI;AAC3B,eAAA,CAAC,IAAI,KAAK;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,wBAEE,QAEA,MAEA,OAEA,WAEA,SAEA,UAEA,YACA;AAEA,UAAM,iBAAiB,CAAC,GAAG,UAAU,MAAM,EACxC,KAAK,EACL,IAAI,CAAC,MAAM,UAAU,IAAI,CAAC,CAAC;AAC9B,aAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AACxC,YAAA,YAAY,eAAe,CAAC;AAClC,UAAI,QAAQ,MAAM,SAAS,CAAC,GAAG;AACxB,aAAA;AAAA,UACH,QAAQ,MAAM,SAAS,CAAC;AAAA,UACxB;AAAA,UACA;AAAA,QAAA;AAGF;AAAA,MACF;AAEA,YAAM,EAAE,MAAM,OAAO,IAAI,KAAK;AAAA,QAC5B;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAO,SAAS;AAAA,QAChB;AAAA,UACE,cAAc;AAAA,QAChB;AAAA,MAAA;AAIF,WAAK,QAAQ,MAAM,SAAS,IAAI,IAAI;AAEpC,WAAK,kBAAkB,IAAI,IAAI,EAAE,MAAM,UAAU;AAGjD,UAAI,CAAC,KAAK,kBAAkB,KAAK,KAAK,GAAG;AAEvC,aAAK,kBAAkB,KAAK,KAAK,IAAI,CAAA;AAAA,MACvC;AAEA,WAAK,kBAAkB,KAAK,KAAK,EAAE,SAAS,IAAI;AAEhD,eAAS,MAAM,SAAS,CAAC,IAAI,KAAK;AAAA,IACpC;AAAA,EACF;AAAA,EAEA,sBAAsB,CAAA;AAAA;AAAA,EAEtB,kBAAkB,MAAM,YAAY,QAAQ;AAE1C,UAAM,eAAe,CAAA;AAEf,UAAA,aAAa,OAAO,KAAK,MAAM;AACjC,QAAA,CAAC,WAAW,OAAQ;AAExB,UAAM,EAAE,WAAW,MAAM,IAAI,KAAK;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAGF,UAAM,UAAU,KAAK,QAAQ,KAAK,KAAK,KAAK;AAE5C,UAAM,WAAY,KAAK,iBAAiB,KAAK,KAAK,IAAI;AACtD,SAAK,kBAAkB,QAAQ,MAAM,OAAO,SAAS,UAAU,UAAU;AAIzE,SAAK,oBAAoB;AAAA,MAAK,MAC5B,KAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IAAA;AAIK,WAAA;AAAA,EACT;AAAA;AAAA,EAGA,mBAAmB,MAAM,aAAa,KAAK;AAEzC,UAAM,WAAY,KAAK,kBAAkB,KAAK,KAAK,IAAI;AAGvD,aAAS,WAAW,GAAG,WAAW,IAAI,OAAO,QAAQ,YAAY;AAE/D,YAAM,YAAY,KAAK,UAAU,KAAK,KAAK;AAErC,YAAA;AAAA;AAAA,QAEJ,YAAY,QAAQ,KAAK,CAAC,KAAK,aAAa,KAAK,KAAK,IAAI,QAAQ;AAAA;AAC9D,YAAA,eACJ,KAAK,SAAS,SAAS,KAAK,KAAK,GAAG,SAAS,QAAQ;AACjD,YAAA,UAAU,cAAc,WAAW,CAAC;AACrC,WAAA,iBAAiB,KAAK,OAAO;AAClC,UAAI,CAAC,SAAS;AACZ;AAAA,MACF;AAGA,eAAS,QAAQ,IAAI,KAAK,QAAQ,OAAO;AAEzC,WAAK,kBAAkB,KAAK,QAAQ,OAAO,MAAM,IAAI;AAAA,QACnD;AAAA,QACA,MAAM;AAAA,MAAA;AAGR,WAAK,QAAQ,OAAO,KAAK,IAAI,OAAO,QAAQ,CAAC;AAE7C,WAAK,QAAQ,eAAe,KAAK,IAAI,eAAe,QAAQ,CAAC;AAE7D,UAAI,QAAQ,cAAc;AAC1B,UAAI,CAAC,OAAO;AACV,gBAAQ,IAAI,cAAc,QAAQ,KAAK,IAAI,OAAO,QAAQ;AAEpD,cAAA,SAAS,KAAK,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,KAAK;AACxD,YAAI,QAAQ,OAAO;AACjB,kBAAQ,OAAO;AAAA,QACjB;AAAA,MACF;AAEA,UAAI,OAAO;AACX,UAAI,QAAQ,aAAa;AACvB,cAAM,SAAS,GAAG,KAAK,SAAS,KAAK,IAAI;AAClC,eAAA,GAAG,MAAM,GAAG,KAAK;AACxB,YAAI,QAAQ,aAAa;AACvB,iBAAO,GAAG,MAAM,GAAG,KAAK,KAAK,IAAI,KAAK;AAAA,QACxC;AAAA,MACF;AACA,kBAAY,IAAI,IAAI;AAGf,WAAA,QAAQ,YAAY,KAAK,IAAI;AAAA,IACpC;AAAA,EACF;AAAA;AAAA,EAGA,aAAa,qBAAqB,YAAY,kBAAkB;AAC9D,eAAW,KAAK,YAAY;AACpB,YAAA,YAAY,WAAW,CAAC;AAE9B,UAAI,aAAa;AACN,iBAAA,KAAK,UAAU,OAAO;AAE/B,YAAI,EAAE,EAAE,QAAQ,UAAU,wBAAwB;AAChD,2BAAiB,KAAK;AAAA,YACpB,MAAM,EAAE;AAAA,YACR,MAAM,oBAAoB,MAAM,GAAG,SAAS,GAAG,CAAC;AAAA,UAAA,CACjD;AAED,2BAAiB,KAAK;AAAA,YACpB,MAAM,GAAG,MAAM,GAAG,SAAS,KAAK;AAAA,YAChC,QAAQ;AAAA,cACN,MAAM;AAAA;AAAA,cAEN,UAAU,wBAAC,MAAM;AACf,uBAAO,WAAW,CAAC;AACnB,kBAAE,OAAO,cAAc;AACrB,kBAAA,OAAO,MAAM,gBAAgB;AAC7B,kBAAA,OAAO,MAAM,UAAU;AAAA,cAC3B,GALU;AAAA,YAMZ;AAAA,UAAA,CACD;AAEY,uBAAA;AAAA,QACf;AAAA,MACF;AAEA,UAAI,WAAY;AAEhB,YAAM,SAAS,IAAI,gBAAgB,GAAG,SAAS;AAC/C,YAAM,OAAO;IACf;AAAA,EACF;AACF;AAEO,MAAM,iBAAiB;AAAA,SAAA;AAAA;AAAA;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,MAAkB;AAC5B,SAAK,OAAO;AACZ,SAAK,YAAY,KAAK,aAAa,WAAW,KAAK;AAE9C,SAAA,KAAK,gBAAgB,CAAC,eAAe;AACxC,WAAK,aAAa;AAElB,eACM,iBAAiB,GACrB,iBAAiB,KAAK,WAAW,QACjC,kBACA;AACM,cAAA,YAAY,KAAK,WAAW,cAAc;AACtC,kBAAA,UAAU,KAAK,KAAK;AAE9B,mBAAW,KAAK,UAAU,WAAW,CAAA,GAAI;AACnC,cAAA,EAAE,SAAS,oBAAoB;AACjC,cAAE,iBAAiB,EAAE;AAAA,UACvB;AAAA,QACF;AAEA,kBAAU,QAAQ;AAER,kBAAA,eAAe,CAAC,SAAS;AAEjC,gBAAM,eACJ,KAAK,UAAU,iBAAiB,UAAU,KAAK,IAAI,IAAI;AACzD,cAAI,gBAAgB,MAAM;AACjB,mBAAA,KAAK,KAAK,aAAa,YAAY;AAAA,UAC5C;AAGA,gBAAM,YAAY,KAAK,UAAU,QAAQ,UAAU,KAAK,IAAI,IAAI;AAC5D,cAAA,CAAC,UAAkB,QAAA;AAEvB,gBAAM,YAAY,WAAW,UAAU,CAAC,CAAC;AAErC,cAAA,UAAU,SAAS,gBAAwB,QAAA;AAExC,iBAAA;AAAA,QAAA;AAIC,kBAAA,eAAe,CAAC,SAAS;AACjC,gBAAM,eACJ,KAAK,UAAU,iBAAiB,UAAU,KAAK,IAAI,IAAI;AACzD,cAAI,gBAAgB,MAAM;AAExB,kBAAM,SAAS,KAAK,KAAK,OAAO,YAAY,EAAE;AAE9C,gBAAIC,QAAO,IAAI,MAAM,MAAM,MAAM;AAGjCA,oBAAO;AAAA,cACL,GAAGA;AAAAA,cACH,WAAW,UAAU;AAAA,cACrB,aAAa,CAAC;AAAA,YAAA;AAETA,mBAAAA;AAAAA,UACT;AAEA,cAAI,OAAO,KAAK,UAAU,QAAQ,UAAU,KAAK,IAAI,IAAI;AACrD,cAAA,CAAC,KAAa,QAAA;AAEX,iBAAA;AAAA,YACL,WAAW,WAAW,KAAK,CAAC,CAAC,EAAE;AAAA,YAC/B,aAAa,KAAK,CAAC;AAAA,YACnB,WAAW,UAAU;AAAA,YACrB,aAAa,CAAC;AAAA,UAAA;AAET,iBAAA;AAAA,QAAA;AAAA,MAEX;AAAA,IAAA;AAGG,SAAA,KAAK,aAAa,CAAC,SAAS;AAGxB,aAAA,EAAE,GAAG;AACZ,YAAM,SAAS,KAAK,UAAU,kBAAkB,KAAK,WAAW;AAChE,UAAI,YAAY,KAAK,WAAW,OAAO,KAAK,KAAK;AAC7C,UAAA;AACG,aAAA,WAAW,SAAS,WAAW;AAChC,YAAA,UAAU,aAAa,CAAC;AAChB,oBAAA,UAAU,aAAa,CAAC;AAAA,MACtC;AAEA,UAAI,CAAC,WAAW;AACP,eAAA;AAAA,MACT;AAEA,UAAI,KAAK,iBAAiB,YAAY,SAAS,GAAG;AACzC,eAAA,UAAU,WAAW,CAAC;AAAA,MAC/B;AAEA,WAAK,YAAY,UAAU;AACtB,WAAA,cAAc,GAAG,eAAe,OAAO;AACrC,aAAA;AAAA,IAAA;AAIT,SAAK,KAAK,gBAAgB,CACxB,kBAEA,mBAAsC,IAEtC,QAAgC,CAAC,GAEjC,UAAU,oBAAI,UACa;AACvB,UAAA,QAAQ,IAAI,KAAK,IAAI;AACjB,cAAA,IAAI,MAAM,2CAA2C;AACrD,cAAA,IAAI,KAAK,IAAI;AAEjB,UAAA,CAAC,KAAK,YAAY;AAEpB,aAAK,KAAK;AAAA;AAAA,UAER,KAAK,UAAU,SAAS,MAAM,IAAI,CAAC,GAAG,MAAM;AAC1C,kBAAM,YAAY,UAAU,WAAW,EAAE,IAAI;AAE7C,sBAAU,UAAU,CAAC;AAErB,sBAAU,KAAK,GAAG,KAAK,KAAK,EAAE,IAAI,CAAC;AAEzB,sBAAA,QAAQ,KAAK,KAAK;AACrB,mBAAA;AAAA,UAAA,CACR;AAAA,QAAA;AAAA,MAEL;AAEA,WAAK,mBAAmB;AAExB,YAAM,yBAAyB,CAAC,GAAG,kBAAkB,KAAK,KAAK,EAAE;AAG3D,YAAA,eAAgB,KAAK,KAAK,OAAO;AAAA,QACrC,iBAAiB,GAAG,EAAE;AAAA,MACnB,KAAA;AAEMF,iBAAAA,SAAQ,KAAK,YAAY;AAClCA,cAAK,UAAU,KAAK,KAAK;AAGnB,cAAA,YAAY,OAAOA,MAAK,EAAE;AAChCA,cAAK,KAAK,UAAU,MAAM,GAAG,EAAE,GAAG,EAAE;AACpC,cAAM,gBAAgB,IAAI;AAAA,UACxBA;AAAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QAAA;AAEFA,cAAK,KAAK;AACV,sBAAc,mBAAmB;AAEjC,cAAM,KAAK,aAAa;AAAA,MAC1B;AACO,aAAA;AAAA,IAAA;AAIJ,SAAA,KAAK,WAAW,YAAY;AACzBT,YAAAA,MAAK,KAAK,KAAK;AACf,YAAA,KAAK,KAAK,KAAK;AAEf,YAAA,QAAQ,KAAK,KAAK,eAAe;AAEvC,YAAMY,aAAY,UAAU,WAAW,KAAK,KAAK,IAAI;AAErD,MAAAA,WAAU,KAAKZ;AAIf,MAAAY,WAAU,cAAc,KAAK;AAEnB,MAAAA,WAAA,KAAK,EAAE;AAEb,UAAA,MAAM,IAAIA,UAAS;AAEvB,MAAAA,WAAU,QAAQ;AAAA;AAAA,QAEhB,KAAK,IAAIA,WAAU,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA;AAAA,QAEjC,KAAK,IAAIA,WAAU,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,MAAA,CAClC;AAGK,YAAA,UAAU,IAAI,iBAAiB,KAAK;AACpC,YAAA,WAAW,QAAQ;AAEzB,MAAAA,WAAU,KAAK,EAAE,UAAU,SAAS,QAAQ,SAAS;AAE3C,MAAAA,WAAA,KAAK,EAAE,aAAa,KAAK;AAC5B,aAAAA;AAAA,IAAA;AAIJ,SAAA,KAAK,iBAAiB,MAAM;AAC/B,YAAM,gBAAgB,6BAAM;AAE1B,cAAM,IAAI,EAAE,GAAG,KAAK,UAAU,SAAS;AACvC,UAAE,QAAQ,CAAC,GAAG,EAAE,KAAK;AAEf,cAAA,aAAa,KAAK,KAAK,cAAc;AAC3C,YAAI,MAAM,CAAA;AACV,iBAAS,IAAI,GAAG,IAAI,EAAE,MAAM,QAAQ,KAAK;AACnCZ,cAAAA,MAAK,aAAa,CAAC,GAAG;AAG1B,cAAIA,OAAM,QAAQ,MAAMA,GAAE,GAAG;AAE3BA,kBAAK;AAAA,UAAA,OACA;AACL,gBAAI,KAAKA,GAAE;AAAA,UACb;AACE,YAAA,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,CAAC,GAAG,IAAAA;QAChC;AACA,6BAAqB,KAAK,UAAU,CAAC,GAAG,IAAI,MAAM;AAElD,cAAM,CAAC,GAAG,CAAC,IAAI,KAAK,KAAK;AACrB,YAAA;AACA,YAAA;AAEE,cAAA,cAAc,IAAI,SACpB,MACA,OAAO,KAAK,IAAI,OAAO,cAAc;AACzC,cAAM,WAAW,CAAA;AACjB,iBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACrCA,gBAAAA,MAAK,YAAY,CAAC;AACxB,gBAAM,UAAU,IAAI,MAAM,YAAYA,GAAE;AAClC,gBAAA,YAAY,WAAW,CAAC;AAC9B,mBAAS,KAAK,OAAO;AAGrB,cAAI,QAAQ,QAAQ,QAAQ,IAAI,CAAC,IAAI,MAAM;AAElC,mBAAA,QAAQ,IAAI,CAAC;AAAA,UACtB;AAEA,cAAI,OAAO,QAAQ,QAAQ,IAAI,CAAC,IAAI,KAAK;AAEjC,kBAAA,QAAQ,IAAI,CAAC;AAAA,UACrB;AAGI,cAAA,CAAC,QAAQ,QAAS;AAGtB,gBAAM,MAAM,KAAK,UAAU,kBAAkB,UAAU,KAAK;AAC5D,cAAI,KAAK;AACD,kBAAA,UAAU,OAAO,KAAK,GAAG;AAE/B,uBAAW,WAAW,SAAS;AACvB,oBAAA,UAAU,IAAI,OAAO;AAC3B,kBAAI,CAAC,QAAS;AAGR,oBAAA,cAAc,KAAK,KAAK,QAAQ;AAAA,gBACpC,CAAC,MAAM,EAAE,SAAS;AAAA,cAAA;AAEpB,kBAAI,gBAAgB,GAAI;AAGpB,kBAAA,UAAU,SAAS,iBAAiB;AAEtC,yBAASa,KAAI,GAAGA,KAAI,QAAQ,QAAQ,QAAQA,MAAK;AAEvC,0BAAA,QAAQA,EAAC,EAAE;AAAA,kBAEjB,KAAK,KAAK,QAAQ,cAAcA,EAAC,EAAE;AAAA,gBACvC;AAAA,cAAA,OACK;AAEL,sBAAM,cAAc,KAAK,KAAK,QAAQ,WAAW;AAE3C,sBAAA,YAAY,QAAQ,QAAQ;AAAA,kBAChC,CAAC,MAAM,EAAE,SAAS;AAAA,gBAAA;AAEpB,oBAAI,CAAC,UAAW;AAEhB,0BAAU,QAAQ,YAAY;AAE9B,yBAAS,IAAI,GAAG,IAAI,YAAY,eAAe,QAAQ,KAAK;AAEhD,4BAAA,cAAc,CAAC,EAAE;AAAA,kBAEzB,YAAY,cAAc,CAAC,EAAE;AAAA,gBACjC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAGA,mBAAW,WAAW,UAAU;AAEtB,kBAAA,IAAI,CAAC,KAAK,OAAO;AAEjB,kBAAA,IAAI,CAAC,KAAK,MAAM;AAAA,QAC1B;AAEO,eAAA,EAAE,UAAU;MAAY,GAvGX;AA2GhB,YAAA,kBAAkB,wBAAC,gBAAgB;AAC5B,mBAAA,kBAAkB,KAAK,UAAU,kBAAkB;AACtDb,gBAAAA,MAAK,YAAY,cAAc;AACrC,gBAAM,UAAU,IAAI,MAAM,YAAYA,GAAE;AACxC,gBAAM,MAAM,KAAK,UAAU,iBAAiB,cAAc;AAC1D,qBAAW,gBAAgB,KAAK;AACxB,kBAAA,cAAc,IAAI,YAAY;AACpC,gBAAI,eAAe,KAAM;AACnB,kBAAA,OAAO,KAAK,OAAO,WAAW;AAChC,gBAAA,KAAK,QAAQ,KAAM;AACvB,kBAAM,OAAO,IAAI,MAAM,MAAM,KAAK,IAAI;AACtC,gBAAI,CAAC,KAAM;AAEX,kBAAM,aAAa,IAAI,MAAM,YAAY,KAAK,SAAS;AAEvD,uBAAW,QAAQ,KAAK,aAAa,SAAS,CAAC,YAAY;AAAA,UAC7D;AAAA,QACF;AAAA,MAAA,GAjBsB;AAqBlB,YAAA,mBAAmB,wBAAC,gBAAgB;AACxC,iBACM,gBAAgB,GACpB,gBAAgB,KAAK,SAAS,QAC9B,iBACA;AACM,gBAAA,SAAS,KAAK,QAAQ,aAAa;AACrC,cAAA,CAAC,OAAO,MAAO;AACnB,gBAAM,QAAQ,CAAC,GAAG,OAAO,KAAK;AAC9B,qBAAW,KAAK,OAAO;AACrB,kBAAM,OAAO,KAAK,UAAU,kBAAkB,aAAa;AAC3D,kBAAM,OAAO,IAAI,MAAM,MAAM,CAAC;AAC9B,kBAAM,aAAa,IAAI,MAAM,YAAY,KAAK,SAAS;AACjD,kBAAA,UAAU,IAAI,MAAM,YAAY,YAAY,KAAK,KAAK,KAAK,CAAC;AAElE,oBAAQ,QAAQ,KAAK,MAAM,YAAY,KAAK,WAAW;AAAA,UACzD;AAAA,QACF;AAAA,MAAA,GAjBuB;AAoBzB,UAAI,OAAO;AAEP,UAAA;AACF,cAAM,EAAE,UAAU,YAAY,IAAI,cAAc;AAChD,wBAAgB,WAAW;AAC3B,yBAAiB,WAAW;AACxB,YAAA,MAAM,OAAO,KAAK,IAAI;AAEnB,eAAA;AAAA,MAAA,UACP;AACA,YAAI,OAAO;MACb;AAAA,IAAA;AAGI,UAAA,sBAAsB,KAAK,KAAK;AAEtC,SAAK,KAAK,sBAAsB,SAAUU,IAAG,SAAS;AAE/B,2BAAA,MAAM,MAAM,SAAS;AAG1C,UAAI,cAAc,QAAQ,UAAU,CAAC,MAAM,EAAE,YAAY,SAAS;AAC9D,UAAA,gBAAgB,GAAI,eAAc,QAAQ;AAAA,UACzC;AACG,cAAA;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,UACE,SAAS;AAAA;AAAA,UAET,UAAU,6BAAM;AAEd,mBAAO,KAAK;UACd,GAHU;AAAA,QAIZ;AAAA,QACA;AAAA,UACE,SAAS;AAAA,UACT,UAAU,6BAAM,iBAAiB,KAAK,IAAI,GAAhC;AAAA,QACZ;AAAA,MAAA;AAAA,IACF;AAII,UAAA,iBAAiB,KAAK,KAAK;AACjC,SAAK,KAAK,iBAAiB,SAAU,KAAK,QAAQ;AAEhC,sBAAA,MAAM,MAAM,SAAS;AAErC,YAAM,OAAO,IAAI;AACjB,UAAI,UAAU;AACd,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAC/B,UAAI,KAAK,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;AAE3B,UAAA,YAAY,KAAK,YAAY,UAAU;AAC3C,UAAI,KAAK;AACT,UAAI,YAAY;AAAA,IAAA;AAIlB,UAAM,mBAAmB,KAAK;AACxB,UAAA,YAAY,KAAK,UAAU;AAC5B,SAAA,mBAAmB,SAAU,KAAK;AAEnB,wBAAA,QAAQ,MAAM,SAAS;AACzC;AAAA;AAAA,QAEE,CAAC,IAAI,kBAAkB,KAAK,MAC5B,KAAK,0BAA0B;AAAA,QAC/B;AAEA,cAAM,IAAI,UAAU,MAAM,KAAK,qBAAqB;AACpD,YAAI,CAAC,EAAG;AACR,cAAM,UAAU,WAAW,EAAE,SAAS,EAAE,IAAI,KAAK,KAAK,qBAAqB,IAAI,UAAU,MAAM,MAAM;AACrG,YAAI,KAAK;AACT,YAAI,OAAO;AACL,cAAA,KAAK,IAAI,YAAY,OAAO;AAC9B,YAAA,YAAY,KAAK,YAAY,UAAU;AAC3C,YAAI,UAAU;AACV,YAAA;AAAA,UACF;AAAA,UACA,CAAC,UAAU,oBAAoB;AAAA,UAC/B,GAAG,QAAQ;AAAA,UACX;AAAA,UACA;AAAA,QAAA;AAEF,YAAI,KAAK;AAET,YAAI,YAAY;AAChB,YAAI,SAAS,SAAS,GAAG,CAAC,UAAU,oBAAoB,CAAC;AACzD,YAAI,QAAQ;AAAA,MACd;AAAA,IAAA;AAII,UAAA,mBAAmB,KAAK,KAAK;AAC9B,SAAA,KAAK,mBAAmB,WAAY;AAEvC,WAAK,iBAAiB;AAEf,aAAA,kBAAkB,MAAM,MAAM,SAAS;AAAA,IAAA;AAGhD,UAAM,OAAO;AACP,UAAA,gBAAgB,KAAK,KAAK;AAC3B,SAAA,KAAK,gBAAgB,WAAY;AAChC,UAAA,CAAC,KAAK,SAAS;AACjB;AAAA,MACF;AACM,YAAA,SAAS,KAAK,UAAU,SAAS;AACvC,UAAI,QAAQ;AACV,mBAAW,KAAK,QAAQ;AAChB,gBAAA,SAAS,OAAO,CAAC,GAAG;AAC1B,qBAAW,KAAK,QAAQ;AACtB,gBAAI,OAAO,CAAC,EAAE,YAAY,MAAO;AACjC,kBAAM,aAAa,KAAK,UAAU,kBAAkB,CAAC,EAAE,CAAC;AAClD,kBAAA,SAAS,KAAK,QAAQ,KAAK,CAACH,OAAMA,GAAE,SAAS,UAAU;AAC7D,gBAAI,QAAQ;AACV,qBAAO,OAAO;AACd,qBAAO,cAAc,MAAM,CAAC,GAAG,EAAE;AAAA,YACnC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGO,aAAA,eAAe,MAAM,MAAM,SAAS;AAAA,IAAA;AAIpC,aAAA,YAAY,MAAM,OAAO,UAAU;AAE1C,YAAM,UAAU,wBAAC,EAAE,aAAa;AACxBP,cAAAA,MAAK,MAAM,MAAM;AACvB,YAAI,CAACA,IAAI;AACT,cAAMS,QAAO,IAAI,MAAM,YAAYT,GAAE;AACrC,YAAIS,MAAM;AAGJ,cAAA,iBAAiB,KAAK,YAAY,UAAU,CAAC,MAAM,EAAE,MAAMT,GAAE;AACnE,YAAI,iBAAiB,IAAI;AAEvB,eAAK,KAAK,wBAAwB;AAC9B,cAAA;AAAA,YACF;AAAA;AAAA,YAEA,SAAS,QAAQ,GAAG,KAAK,KAAK,EAAE,IAAI,KAAK,IAAI;AAAA,UAAA;AAAA,QAEjD;AAAA,MAAA,GAhBc;AAkBZ,UAAA,iBAAiB,MAAM,OAAO;AAC3B,aAAA;AAAA,IACT;AAtBS;AAwBT,UAAM,YAAY,YAAY;AAAA,MAC5B;AAAA,MACA;AAAA;AAAA,MAEA,CAAC,MAAM;AAAA;AAAA,MAEP,CAACU,IAAGV,QAAOA;AAAAA,IAAA;AAGb,UAAM,WAAW,YAAY;AAAA,MAC3B;AAAA,MACA;AAAA;AAAA,MAEA,CAAC,MAAM,GAAG,gBAAgB,GAAG;AAAA;AAAA,MAE7B,CAAC,GAAGA,KAAIS,WAAU;AAAA,QAChB,GAAG;AAAA,QACH,MAAMT;AAAAA,QACN,cAAcA;AAAAA,QACd,OAAO,CAACS,MAAK;AAAA,MAAA;AAAA,IACf;AAGF,UAAM,YAAY,KAAK;AAClB,SAAA,KAAK,YAAY,WAAY;AAErB,iBAAA,MAAM,MAAM,SAAS;AAC5B,UAAA,oBAAoB,aAAa,SAAS;AAC1C,UAAA,oBAAoB,YAAY,QAAQ;AAAA,IAAA;AAGzC,SAAA,KAAK,qBAAqB,CAAC,SAAS;AAE5B,iBAAA,cAAc,KAAK,UAAU,mBAAmB;AAEnD,cAAA,SAAS,KAAK,KAAK,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU;AAC9D,YAAA,QAAQ,SAAS,SAAS;AAC5B,gBAAM,MAAM,KAAK,UAAU,kBAAkB,UAAU;AACvD,gBAAM,MAAM,KAAK,IAAI,KAAK,IAAI;AACxB,gBAAA,QACJ,KAAK,OAAO,WAAW,IAAI,SAAS,KACpC,KAAK,OAAO,WAAW,IAAI,SAAS;AACtC,cAAI,CAAC,MAAO;AAEL,iBAAA,QAAQ,SAAS,MAAM,CAAC;AAE/B,cACE,IAAI,cAAc;AAAA,UAElB,CAAC,OAAO,QAAQ,OAAO,SAAS,OAAO,KAAK,GAC5C;AAEA,mBAAO,QAAQ,OAAO,QAAQ,OAAO,CAAC;AAE/B,mBAAA,SAAS,OAAO,KAAK;AAAA,UAC9B;AAAA,QACF;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,qBAAqB;AACR,eAAA,iBAAiB,KAAK,UAAU,mBAAmB;AAEtD,YAAA,YAAY,KAAK,KAAK,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,aAAa;AACxE,UAAI,CAAC,UAAW;AAEhB,YAAM,WAAW,UAAU;AAC3B,YAAM,MAAM,KAAK,UAAU,kBAAkB,aAAa;AAC1D,UAAI,YAAY,KAAK,WAAW,IAAI,KAAK,KAAK;AAE1C,UAAA,UAAU,SAAS,iBAAiB;AACtC,kBAAU,iBAAiB;AAC3B,cAAM,kBAAkB,KAAK,UAAU,kBAAkB,IAAI,KAAK,KAAK;AAC5D,mBAAA,UAAU,mBAAmB,IAAI;AAC1C,gBAAM,OAAO,KAAK,WAAW,OAAO,MAAM;AAEpCK,gBAAAA,UAAS,KAAK,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,OAAO,SAAS;AAEnE,cAAIA,SAAQ;AACVA,oBAAO,QAAQ;AAAA,UACjB;AAAA,QACF;AACA;AAAA,MAAA,WACS,UAAU,SAAS,WAAW;AACvC,cAAM,eAAe,KAAK,UAAU,UAAU,IAAI,KAAK,KAAK;AAC5D,YAAI,cAAc;AACL,qBAAA,CAACJ,MAAK,cAAc,UAAU,KAAK,aAAa,GAAG,GAAG;AACzD,kBAAA,OAAO,KAAK,WAAW,YAAY;AACnC,kBAAA,QAAQ,KAAK,OAAO,UAAU;AACpC,gBAAI,MAAM,QAAQ;AACVI,oBAAAA,UAAS,KAAK,SAAS;AAAA;AAAA,gBAE3B,CAAC,MAAM,EAAE,SAAS,MAAM,OAAO;AAAA,cAAA;AAEjC,kBAAIA,SAAQ;AACVA,wBAAO,QAAQ;AAAA,cACjB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGM,YAAA,SAAS,UAAU,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI,SAAS;AACtE,UAAI,QAAQ;AACV,eAAO,QAAQ;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,kBAAkB,OAAO,QAAQ,SAAS;AAExC,UAAM,cAAc,KAAK,UAAU,kBAAkB,MAAM,IAAI,OAAO;AACtE,QAAI,eAAe,KAAM;AACzB,UAAM,mBACJ,KAAK,UAAU,kBAAkB,WAAW,EAAE,OAAO;AAEjD,UAAA,oBAAoB,KAAK,KAAK,QAAQ;AAAA,MAC1C,CAAC,MAAM,EAAE,SAAS;AAAA,IAAA;AAEpB,QAAI,oBAAoB,IAAI;AACpB,YAAA,gBAAgB,KAAK,WAAW,WAAW;AAC7C,UAAA,MAAM,cAAc,QAAQ;AAChC,UACE,MAAM;AAAA,MAEN,KAAK,KAAK,QAAQ,iBAAiB,EAAE,eAAe,QACpD;AAGM,cAAA;AAAA,MACR;AACA,eAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAEvB,aAAA,KAAK,QAAQ,oBAAoB,CAAC,EAAE,QACvC,cAAc,QAAQ,CAAC,EAAE;AAAA,MAC7B;AAAA,IACF;AACO,WAAA;AAAA,EACT;AAAA;AAAA,EAGA,gBAAgB,MAAM,QAAQ,KAAK;AAC7B,QAAA,KAAK,SAAS,UAAW;AAEvB,UAAA,OAAO,KAAK,UAAU,UAAU,MAAM,IAAI,CAAC,IAAI,CAAC;AACtD,QAAI,CAAC,KAAM;AACX,UAAM,KAAK,cAAc,cAAc,IAAI;AAC3C,UAAM,aAAa,KAAK,UAAU,SAAS,MAAM,YAAY;AAC7D,UAAM,SAAS,WAAW;AACpB,UAAA,eAAe,SAAS,cAAc,GAAG;AAC/C,QAAI,CAAC,aAAc;AAEnB,UAAM,SAAS,OAAO,UAAU,WAAW,gBAAgB,UAAU;AACrE,UAAM,IAAI,WAAW,iBAAiB,iBAAiB,MAAM;AAC7D,QAAI,KAAK,KAAM;AAEf,UAAM,aAAa,OAAO,OAAO,GAAG,EAAE,CAAC;AAEjC,UAAA,SAAS,KAAK,KAAK,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU;AAClE,QAAI,QAAQ;AACV,aAAO,QAAQ;AAAA,IACjB;AAAA,EACF;AAAA,EAEA,kBAAkB;AACZ,QAAA,CAAC,KAAK,KAAK,QAAS;AAGlB,aAAA,SAAS,GACb,SAAS,KAAK,UAAU,SAAS,MAAM,QACvC,UACA;AACA,YAAM,OAAO,KAAK,UAAU,SAAS,MAAM,MAAM;AACjD,YAAM,MAAM,KAAK,UAAU,kBAAkB,MAAM,KAAK;AAClD,YAAA,UAAU,OAAO,KAAK,GAAG;AAE3B,UAAA,CAAC,KAAK,gBAAgB,QAAQ;AAG3B,aAAA,gBAAgB,MAAM,QAAQ,GAAG;AACtC;AAAA,MACF;AAEA,UAAI,cAAc;AAClB,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACjC,cAAA,UAAU,QAAQ,CAAC;AACnB,cAAA,UAAU,IAAI,OAAO;AACrB,cAAA,cAAc,KAAK,KAAK,QAAQ;AAAA,UACpC,CAAC,MAAM,EAAE,SAAS;AAAA,QAAA;AAEpB,cAAM,aAAa,KAAK,KAAK,QAAQ,WAAW;AAChD,YACE,KAAK,kBAAkB,MAAM,QAAQ,OAAO,KAC5C,gBAAgB,IAChB;AAEA,gBAAM,cAAc,KAAK,WAAW,MAAM,EAAE,SAAS;AAAA;AAAA,YAEnD,CAAC,MAAM,EAAE,SAAS;AAAA,UAAA;AAEL,yBAAA,aAAa,eAAe,UAAU;AAAA,QACvD;AACA,YAAI,gBAAgB,IAAI;AACtB;AAAA,QACF;AAGA,mBAAW,QAAQ,KAAK,eAAe,IAAI,WAAW;AAEtD,iBAAS,IAAI,GAAG,IAAI,WAAW,eAAe,QAAQ,KAAK;AACpD,eAAA,KAAK,QAAQ,cAAc,IAAI,CAAC,EAAE,QACrC,KAAK,eAAe,IAAI,EAAE,WAAW;AAAA,QACzC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,aAAa,OAAO;AACd,QAAA;AACA,QAAA;AAEJ,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAC/B,YAAA,OAAO,MAAM,CAAC;AACpB,UAAI,QAAQ,QAAQ,KAAK,IAAI,CAAC,IAAI,MAAM;AAC/B,eAAA,KAAK,IAAI,CAAC;AAAA,MACnB;AACA,UAAI,OAAO,QAAQ,KAAK,IAAI,CAAC,IAAI,KAAK;AAC9B,cAAA,KAAK,IAAI,CAAC;AAAA,MAClB;AAEK,WAAA,YAAY,MAAM,CAAC;AACpB,UAAA,MAAM,OAAO,IAAI;AAGrB,WAAK,KAAK,GAAG,KAAK,KAAK,EAAE,IAAI,CAAC;AAAA,IAChC;AAEA,SAAK,WAAW;AAChB,SAAK,KAAK,MAAM,CAAC,MAAM,GAAG;AAAA,EAC5B;AAAA;AAAA,EAGA,YAAY,cAAc,QAAQ;AAC5B,QAAA,CAAC,aAAa,QAAS;AAEhB,eAAA,UAAU,aAAa,SAAS;AACrC,UAAA,CAAC,OAAO,MAAO;AAEnB,YAAM,QAAQ,CAAC,GAAG,OAAO,KAAK;AAC9B,iBAAW,KAAK,OAAO;AACrB,cAAM,OAAO,IAAI,MAAM,MAAM,CAAC;AAC9B,YAAI,CAAC,KAAM;AAEX,cAAM,aAAa,IAAI,MAAM,YAAY,KAAK,SAAS;AACvD,cAAM,UACJ,KAAK,UAAU,kBAAkB,MAAM,IAAI,KAAK,WAAW;AAC7D,YAAI,WAAW,MAAM;AAEnB,eAAK,KAAK,QAAQ,SAAS,YAAY,KAAK,WAAW;AAAA,QACzD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,aAAa;AACX,eAAW,QAAQ,KAAK,UAAU,SAAS,SAAS,IAAI;AACtD,YAAM,CAAA,EAAG,YAAY,UAAU,YAAY,cAAc,IAAI;AAC7D,YAAM,aAAa,IAAI,MAAM,YAAY,cAAc;AACvD,UAAI,CAAC,WAAY;AACN,iBAAA;AAAA,QACT;AAAA;AAAA,QAEA,KAAK,KAAK;AAAA,QACV,KAAK,UAAU,iBAAiB,QAAQ,EAAE,UAAU;AAAA,MAAA;AAAA,IAExD;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,aAAa,MAAM;AACxB,YAAQ,KAAK,YAAY,KAAK,aAAa,YAAY,KAAK;AAAA,EAC9D;AAAA,EAEA,OAAO,YAAY,MAAkB;AACnC,WAAO,CAAC,CAAC,KAAK,aAAa,WAAW,KAAK;AAAA,EAC7C;AAAA,EAEA,aAAa,UAAU,OAAqB;AAEpC,UAAA,UAAU,IAAI,iBAAiB,KAAK;AACpC,UAAA,MAAM,MAAM,QAAQ;AAC1B,QAAI,CAAC,IAAK;AAEJ,UAAA,EAAE,MAAM,SAAa,IAAA;AAG3B,UAAM,SAAS,IAAI,gBAAgB,MAAM,QAAQ;AACjD,UAAM,OAAO;AAEP,UAAAF,aAAY,UAAU,WAAW,GAAG,MAAM,GAAG,SAAS,GAAG,IAAI,EAAE;AAG3D,IAAAA,WAAA,cAAc,QAAQ,KAAK;AAE3B,IAAAA,WAAA,KAAK,EAAE;AAEb,QAAA,MAAM,IAAIA,UAAS;AAIvB,IAAAA,WAAU,KAAK,EAAE,aAAa,QAAQ,KAAK;AACpC,WAAAA;AAAA,EACT;AACF;AAEA,MAAM,0BAA0B,wBAAC,UAA6B;AAC5D,aAAW,QAAQ,OAAO;AACpB,QAAA,OAAO,KAAK,SAAS,YAAY,KAAK,KAAK,WAAW,WAAW,GAAG;AACjE,WAAA,OAAO,KAAK,KAAK,QAAQ,eAAe,GAAG,MAAM,GAAG,SAAS,EAAE;AAAA,IACtE;AAAA,EACF;AACF,GANgC;AAiBhC,eAAe,kCAAkC;AAC/C,QAAM,QAAQ,OAAO,OAAO,IAAI,OAAO,kBAAkB,CAAA,CAAE;AACvD,MAAA,MAAM,WAAW,GAAG;AAChB,UAAA,IAAI,MAAM,mBAAmB;AAAA,EACrC;AACI,MAAA,MAAM,WAAW,GAAG;AAChB,UAAA,IAAI,MAAM,uDAAuD;AAAA,EACzE;AAEA,aAAW,QAAQ,OAAO;AACxB,QAAI,gBAAgB,cAAc;AAC1B,YAAA,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AACI,QAAA,iBAAiB,YAAY,IAAI,GAAG;AAChC,YAAA,IAAI,MAAM,qCAAqC;AAAA,IACvD;AAAA,EACF;AACO,SAAA,MAAM,iBAAiB,UAAU,KAAK;AAC/C;AAlBe;AAoBf,SAAS,4BAA4B;AACnC,QAAM,QAAQ,OAAO,OAAO,IAAI,OAAO,kBAAkB,CAAA,CAAE;AAC3D,aAAW,QAAQ,OAAO;AACpB,QAAA,iBAAiB,YAAY,IAAI,GAAG;AACtC,WAAK,iBAAiB;AAAA,IACxB;AAAA,EACF;AACF;AAPS;AAST,SAAS,iBAAiB,MAAe;AACvC,MAAI,kBAAkB,GAAG,EAAE,KAAK,IAAI;AACtC;AAFS;AAIT,MAAM,KAAK;AAEX,IAAI;AACJ,MAAM,MAAsB;AAAA,EAC1B,MAAM;AAAA,EACN,UAAU;AAAA,IACR;AAAA,MACE,IAAI;AAAA,MACJ,OAAO;AAAA,MACP,MAAM;AAAA,MACN,cAAc;AAAA,MACd,UAAU;AAAA,IACZ;AAAA,IACA;AAAA,MACE,IAAI;AAAA,MACJ,OAAO;AAAA,MACP,MAAM;AAAA,MACN,cAAc;AAAA,MACd,UAAU;AAAA,IACZ;AAAA,IACA;AAAA,MACE,IAAI;AAAA,MACJ,OAAO;AAAA,MACP,MAAM;AAAA,MACN,cAAc;AAAA,MACd,UAAU;AAAA,IACZ;AAAA,EACF;AAAA,EACA,aAAa;AAAA,IACX;AAAA,MACE,WAAW;AAAA,MACX,OAAO;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACP;AAAA,IACF;AAAA,IACA;AAAA,MACE,WAAW;AAAA,MACX,OAAO;AAAA,QACL,KAAK;AAAA,QACL,OAAO;AAAA,QACP,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,qBACJ,WACA,kBACA;AACM,UAAA,QAAQ,WAAW,OAAO;AAChC,QAAI,OAAO;AACT,8BAAwB,UAAU,KAAK;AACjC,YAAA,gBAAgB,qBAAqB,OAAO,gBAAgB;AAAA,IACpE;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM;AAET,iBAAA;AAAA,EACf;AAAA,EACA,YAAY,MAAM;AACZ,QAAA,iBAAiB,YAAY,IAAI,GAAG;AAEtC,WAAK,KAAK,IAAI,IAAI,iBAAiB,IAAI;AAIvC,UAAI,KAAK,SAAS,KAAK,KAAK,GAAG,WAAW,UAAU;AAElD,iBAAS,eAAe,KAAK,OAAO,KAAK,KAAK,EAAE,UAAU,QAAQ;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAEA,MAAM,oBAAoB,MAAM;AAGvB,WAAA,OAAO,YAAY,IAAI;AACxB,UAAA,QAAQ,IAAI,MAAM,OAAO;AAC/B,QAAI,OAAO;AACT,YAAM,gBAAgB,qBAAqB,OAAO,CAAE,CAAA;AAAA,IACtD;AAAA,EACF;AACF;AAEA,IAAI,kBAAkB,GAAG;;;;;;;;;;"}